{"./":{"url":"./","title":"Introduction","keywords":"","body":"Conan Tutorial 由于工作原因，常常会在各种编程语言技术栈下切换。每次切回到C/C++技术栈下，都会为C/C++语言缺乏一个好用的包管理器而不适应好一阵。 包管理器的存在可以让程序功能单元的组织满足闭包化（隐藏源码、依赖和构建细节）、契约化（显示的API导出、变更和版本管理）以及标准化（体验一致的本地客户端、中央仓、及其在工具约束下的标准开发活动等等）。这些都能够让软件功能的复用变得更加黑盒和简单，降低程序的复用成本。 这些优点对于社区化开发是非常重要的。离散的社区团队之间需要有一种标准和契约，可以低成本的信任和依赖别人发布的代码和更新。关于C/C++语言需要一个好用的包管理器这件事，已经被社区呼吁很久了。 大多数C/C++程序员都羡慕过NodeJS下有npm、RUST下有cargo，就连一贯采用单一代码库的google也因为社区的需要从golang 1.11版本开始引入了go modules机制来支持包管理。回过头来我们不禁会问，为C/C++语言做一款好用的包管理器真的有那么难吗？ 答案是确实挺难！这里面涉及到多方面的原因，而且不仅仅是技术的原因。 首先是C/C++语言自身的问题。C/C++程序的构建是底层相关的，这导致当你创建一个包的时候，必须考虑目标的操作系统、体系架构、以及构建时使用的编译器类型和版本、构建类型（Debug/Release）等一系列影响依赖方能否正常使用的因素。 此外，你还需要关注一些包自身的属性：是纯头文件库、静态库还是动态库，以及包的构建参数（比如优化级别、是否开启exception和rtti的编译选项...）、还有指定裁剪性(特性宏)等配置。 另外，由于C/C++的标准库（glibc和libstdc++）存在版本兼容性问题，以及C++存在ABI兼容性问题，这会让包的版本管理超越语义化版本(SemVer)所能解决的问题范围，这导致包的创建者需要在发包的时候为包的兼容性做更多的考虑。 最后，由于C/C++语言在语法上缺乏包级别的模块化机制，会让包的符号冲突以及依赖解决变得困难。 如果上述还不够，那么在这些的基础上，再加上交叉编译的场景，绝对会让一个通用C/C++包管理器的复杂度超过其它任何语言。 上述问题，整个C/C++社区中的组织和开发者一直都在努力解决。然而不像别的语言（golang属于google，rust属于社区），C/C++是由标准委员会和各个编译器工具背后的商业组织共同推动的（主要是C++，但是C受制于不同的Linux发行版本和工具链），所以无论是从效率还是结果上都不是那么好。 所以这个社区是分裂的，只用看看有多少种编译构建系统就知道了：gcc、clang、intel、qcc、Visual Studio（MSBuild）、Makefiles、Ninja、Scons、CMake...。同样，在缺少通用包管理的情况下，大家对于代码复用的解决方式也发展出了各种模式。 首先是基于源码的复用方式。项目只要划好模块，定义好各自的模块目录以及share的头文件目录，然后就可以分工合作了。 这种方式的问题是代码都在单一代码库中，可以直接看到对方的源码。由于互相之间的依赖是隐式的，导致不容易对代码做溯源和裁剪。当然这首先是个设计问题，但是这种复用方式让工具不容易对现状作出有效的可视化和约束管理。 在这种方式下，大家很容易商量出一个公共的common头文件目录，将每个模块公开的头文件都放里面（因为成本很低，无论是手动还是构建过程中自动完成）。任何一个模块依赖别人似乎都很简单，但是最后所有模块都耦合到了一起。 而且这种方式下，代码库会膨胀的很快，所有变更最终都会拥挤到一条效率不高的持续集成流水线上。由于依赖的隐式化，为持续集成流水线做分层和优化需要花费比较大的精力。 后来围绕着Git，人们发展出了一些能够优化“基于源码复用”的工具，如git submodule、git subtree、git repo等。这些工具可以把代码分布到不同的git仓库和分支中，能为每个代码仓搭建自己的CI流水线。但是这些方式没有从根本上解决依赖白盒化的问题。由于在使用这些工具的时候，大家仍然优先倾向将所有源码拉到一起后再进行构建，因此每个库的独立构建、测试和发布其实是缺乏原动力的。 一些构建工具的发展，为C/C++的代码复用引入了更好的方式。例如CMake从3.0版本开始被称之为“Modern CMake”，是因为它引入了target的概念，以及基于target建立起了构建的依赖可见性和传播控制机制。这些都更好的支持了代码在构建上的模块化，号称“everything is a (self-contained) target”。另外，借助CMake的ExternalProject和find_package特性，使得我们可以从指定的http或者git分支下载、构建、安装和引用代码库。由于CMake的广泛流行，目前这已经成为C/C++开源社区的事实标准。关于Modern CMake的用法和最佳实践，可以看看这篇文章：《Modern CMake最佳实践》。 另外，Google的Bazel也具有类似的模块化构建和依赖管理的能力，在某些方面它还要更强大一些，并且支持云构建和缓存。但是由于其它一些原因，并没有大规模流行起来。我的好朋友刘光聪写过系列文章对bazel做过分析和介绍，具体可以看看： 《Bazel是把双刃剑》。 上述构建工具提供的代码复用能力，使得C/C++从代码的白盒复用往黑盒复用上迈进了一大步：代码的发布方至少要保证自己代码库的构建闭包性。但是这种复用方式，对于间接依赖的管理仍旧是不足的。我们需要一种能力，可以通过全链条的依赖解析，进行依赖溯源、冲突判决，以及基于变更进行最小范围的重构建和发布管理。 所以，包管理器在C/C++社区很早就有了。包管理器通过让包显示化的描述自己的元信息：名称、版本、构建方式、以及所有的依赖包的版本信息，标准化了包的构建、发布和复用方式，以及自动化的对依赖和变更做管理。 遗憾的是如我们前面所说，C/C++的构建以及二进制兼容性的外部影响因素太多，所以现有被广泛使用的包管理器往往是局限于某种系统类型内的。例如Linux下主流的rpm和deb就分别面向不同的linux发行版（如Fedora和Ubuntu，当然可以扩展）。这种方式简化了C/C++的构建和二进制兼容性的管理（还包括标准库的兼容性管理），因此让包管理器的设计和使用变得容易。遗憾的是，这样的包管理器对于更广泛的社区化开发是不够的。 不过，社区一直没有停止过努力的脚步。Biicode是一款探索以源码发包的现代化C/C++包管理器，但遗憾的是这个项目由于经营原因在2015年关闭了。Biicode在关闭前开源了它所有的源码，刚好那个时候我也和几个朋友也一起创建了一个C/C++包管理的项目CUP，遗憾的是由于精力原因这个项目一直未能完成。 幸运的是，后来我看到了conan，一款出色的开源C/C++包管理器。它吸收了很多现代化包管理器的设计思想，探索解决通用C/C++包管理器的各种挑战，而且每个方面都解决的很不错。 借用Conan文档中的介绍：“Conan is a dependency and package manager for C and C++ languages. It is free and open-source, and it works in all platforms，also integrates with all build systems...”。 Conan支持交叉编译，如果获取匹配的二进制包失败会尝试从源码进行构建。除了基本的包管理能力外，conan试图内置以包管理为中心的开发最佳实践，包括内置的代码布局(layout)、构建、包测试、发布、以及与Git、IDE、CI和部署工具的集成。这些都让C/C++开发逐渐有了类似于在RUST下使用Cargo的感觉。我把这些归为是现代化包管理器应有的能力，当然conan还有一些工作要做，包括语言自身的完善（例如C++20标准引入的module机制），但目前的使用体验已经不错了。唯独可能会对使用者造成门槛的是，conan的包配置描述需要使用python。 https://ccup.github.io/conan-docs-zh/是我在官网学习Conan的过程中，一边学习一边翻译记录的结果。最初的目的是通过翻译让自己对看过的东西加深印象，虽然还没有完全完成，但还是先稍加整理提供给有需要的同学吧。 在翻译记录的过程中，我根据个人的感觉对内容做了些取舍。中间有很小的部分加了点个人的理解，以使得整体更加易懂。因此，这个手册不保证更新以及和官网完全一致，有精力的同学还是推荐大家尽可能阅读官方文档。 最后，还想讨论一个话题，那就是在集中管控式的大型C/C++项目中有没有必要将类似于Conan这样的包管理能力内置于开发过程中。 和社区化开发不同，这些项目可以通过集中的项目管理手段协调内部的协作和复用，再加上一些我们前面提的源码和模块化构建的技术手段，大多数时候确实可以不需要包管理器。但是我见过很多大型C/C++项目，代码动辄百万、千万，涉及很多可复用的功能单元，由于缺乏包管理器对依赖进行显示化管理，最后内部依赖混乱复杂，以至于源码的追溯性和构建的可重复性都变得困难。这些项目为了解决问题，会自行制定代码标准，开发内部工具，但是做的很多工作在我看来都是使用一款包管理器就可以解决的。 当然，这些项目宁愿自行定义标准和开发工具，而不使用包管理，是有原因的。首先，包管理一般具有侵入性，引入包管理势必需要改造现有的开发和协作模式，对于遗留系统的改造成本可能会比较大。另外，采用包管理还可能会让跨模块的变更变得低效。 大多数项目在初期时候，变化方向不明确，因此系统内部结构是不稳定的。在中期结构稳定后，可能又缺乏演进式设计和重构能力，对软件结构的划分未必能保证低耦合。如果当大多数变更都需要跨越多个包的时候，采用包管理这种隔离性强的方式，反而会增大协作沟通成本，降低效率。幸运的是，conan提供了editable mode package和workspace的特性(RUST的cargo也提供了这个特性)，来让多包协作的修改变得稍微容易一些。 许多编程语言都把包管理器作为一个抓手，围绕着包开发来打造贯穿整个开发过程的最佳实践和辅助工具。包管理的引入会将原有的软件模块团队的交付终点，从仅仅将代码合入到代码库，延长到了需要保证构建、测试、打包和发布成功，并且满足包版本的发布契约（验收测试和契约测试），从而真正意义上的使能团队独立流水线，推动了团队的devops能力。 因此我觉得，随着C/C++包管理器的成熟，以及对软件开发过程支持的更加完善，会有越来越多的C/C++新项目逐步开始使用包管理器。而那些改造负担大，或者已经有自己的标准和工具来替代包管理能力的项目，也不妨多关注C/C++社区现代化包管理的现状和进展，从中学习和借鉴一些经验，让自己的标准和工具做的更好。 最后，再说一句，包管理只是一系列工具以及基于这些工具所构建的公共能力，它早已被证明不是银弹！包划分的好不好依然依赖于软件设计能力，这在某种程度上和微服务是一样的。你一定听说过很多关于服务拆分不好带来问题的故事吧，幸运的是包划分不好的成本比这低一些，但仍旧是有成本的。 本系列文档的github库地址：https://github.com/ccup/conan-docs-zh/。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-15 15:35:13 "},"01-introduction.html":{"url":"01-introduction.html","title":"Conan介绍","keywords":"","body":"Conan介绍 Conan是一个可以帮C/C++进行依赖管理的包管理器。它是免费、开源、跨平台的。目前支持Windows, Linux, OSX, FreeBSD, Solaris等平台。同时也支持嵌入式、移动端（IOS，Andriod）、或者直接基于裸机之上的目标程序开发。它当前支持各种构件系统，例如CMake，Visual Studio（MSBuild），Makefiles，Scons等等。 Conan是分布式的，它允许运行自己私有的包管理器托管自己私有的包和二进制文件。Conan是基于二进制管理的，它可以为包生成各种不同配置、不同体系架构或者编译器版本的二进制文件。 Conan相对比较成熟和稳定，有一个全职团队在维护它。Conan保证前向兼容，社区相对成熟，从开源到商业公司都有使用。它有一个官方的中央仓 ConanCenter。 Conan的源码遵循 MIT license，位于github : https://github.com/conan-io/conan。 分布式的包管理器 Conan是分布式的，遵循C/S架构。客户端可以从不同的远端server上获取或上传包。和git的git pull和git push类似。 Conan的服务端主要负责包的存储，并不构建和产生包。包产生于Conan的客户端，包括包中的二进制也是在客户端编译而成。 上图描述了conan的主要组成： Conan Client：Conan的客户端。它是一个基于命令行的程序，支持包的创建和使用。Conan客户端有一个包的本地缓存，因此你可以完全离线的创建和测试和使用本地的包。 JFrog Artifactory Community Edition (CE)：JFrog Artifactory Community Edition (CE)是官方推荐的用于私有部署的Conan服务器程序。这个是JFrog Artifactory的免费社区版，包含了WebUI、LDAP协议、拓扑管理、REST API以及能够存储构建物的通用仓库。下载Docker Image：docker pull docker.bintray.io/jfrog/artifactory-cpp-ce，运行方式参见文档。 Conan Server：这是一个与Conan Client一起发布的小的服务端程序。它是一个Conan服务端的开源实现，只包含服务端的基本功能，没有WebUI以及其它高级功能。 ConanCenter：这是官方的中央仓，用于管理社区贡献的各种流行开源库，例如Boost，Zlib，OpenSSL，Poco等。 基于二进制的包管理 Conan最强大的特性使它能为任何可能的平台和配置生成和管理预编译的二级制文件。使用预编译的二进制文件可以避免用户反复的从源码进行构建，节省大量的开发以及持续集成服务器用于构建的时间，同时也提高了交付件的可重现性和可跟踪性。 Conan中的包由一个\"conanfile.py\"定义。该文件定义了包的依赖、包含的源码、以及如何从源码构建出二进制文件。一个包的\"conanfile.py\"配置可以生成任意数量的二进制文件，每个二进制可以面向不同的平台和配置（操作系统、体系结构、编译器、以及构件类型等等）。二进制的创建和上传，在所有平台上使用相同的命令，并且都是基于一套包的源码产生的。使用Conan不用为不同的操作系统提供不同的解决方案。 使用Conan从服务器安装包也很高效。只用从服务端下载所需平台和配置对应的二进制文件即可，不用下载所有的二进制。如果所有的二进制都不可用，也可以用客户端的源码重新构建包。 支持所有的平台，构建系统以及编译器 Conan可以工作在Windows, Linux (Ubuntu, Debian, RedHat, ArchLinux, Raspbian), OSX, FreeBSD, 以及 SunOS系统上。因为它是可移植的，其实它可以运行在所有可以运行python的平台上。它的目标是针对所有存在的平台，从裸机到桌面端、移动端、嵌入式以及交叉编译。 Conan支持当前所有的构建系统。它内建了与当前最流行的构建系统的集成，例如CMake、Visual Studio (MSBuild)、 Autotools、 Makefiles, SCons等等。Conan并不强制所有的包都是用相同的构建系统，每个包可以使用自己的构架系统，并且可以依赖于使用不同构建系统的其它包。Conan也支持与其它构建系统继承，包括一些专有的构建系统。 Conan支持管理任何编译器的任何版本，包含主流的gcc、cl.exe、clang、apple-clang、intel等，支持它们的各种配置、版本、运行时和C++标准库。Conan也支持各种客户自定义的编译器配置。 稳定性 从Conan1.0之后，开发团队保证Conan的前向兼容性，新的版本不破坏之前的用户配置和包构建发布。而使用老的Conan版本并不保证可以兼容新的包定义。 Conan需要Python3来运行，对Python2的支持到2020年1月1日。从Conan 1.22.0版本开始，不再保证Python2的支持。 社区 Conan当前被 Audi、 Continental、 Plex、 Electrolux、 Mercedes-Benz等公司以及全球数万开发者用于生产环境中。 Conan在github上拥有3.6k的星，许多客户为ConanCenter创建各种流行的开源库的包，超过1000名Conan用户在slack上的CppLang Slack#Conan频道中帮助回答问题。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"02-Install.html":{"url":"02-Install.html","title":"安装","keywords":"","body":"安装 通过pip安装（官方推荐） 需要Python版本大于等于3.5。Python 3.4以及Python2的支持将被废弃。新的Python都会预装pip，所以应该可以直接运行pip。 pip install conan 如果你的机器同时有python2和python3，可能需要运行： pip3 install conan OSX安装 MAC上可以使用brew直接安装： brew update brew install conan 二进制安装 也可以从conan官网上直接下载二进制安装：https://conan.io/downloads.html 源码安装 确保你预装了python和pip。 git clone https://github.com/conan-io/conan.git cd conan pip install -r conans/requirements.txt 创建一个脚本，将其加入你的path路径中： #!/usr/bin/env python import sys conan_repo_path = \"/home/your_user/conan\" # ABSOLUTE PATH TO CONAN REPOSITORY FOLDER sys.path.append(conan_repo_path) from conans.client.command import main main(sys.argv[1:]) 测试conan安装OK： $ conan 打印类似如下，说明安装OK Consumer commands install Installs the requirements specified in a recipe (conanfile.py or conanfile.txt). config Manages Conan configuration. get Gets a file or list a directory of a given reference or package. info Gets information about the dependency graph of a recipe. ... 升级 最简单的方式： $ pip install conan --upgrade Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"03-getting-started.html":{"url":"03-getting-started.html","title":"快速开始","keywords":"","body":"快速开始 以开发一个“MD5计算器”程序为例，它依赖了一个非常流行的C++的网络库Poco来帮助它完成功能。 这个例子使用CMake作为构建工具，也可以使用别的构建工具。 这个例子的源码在github上，所以你也可以直接把代码clone下来，不用自己手动敲代码。 $ git clone https://github.com/conan-io/examples.git && cd examples/libraries/poco/md5 https://github.com/conan-io/examples.git仓库里面有conan各种用法的例子，建议clone下来系统的学习一下。 继续回到本例，按照以下步骤执行。 运行示例 首先创建一个目录，在里面创建一个md5.cpp文件，包含以下内容： // md5.cpp #include \"Poco/MD5Engine.h\" #include \"Poco/DigestStream.h\" #include int main(int argc, char** argv) { Poco::MD5Engine md5; Poco::DigestOutputStream ds(md5); ds 我们知道这个程序依赖Poco库，所以先让conan从ConanCenter中查找阿和库。 $ conan search poco --remote=conan-center Existing package recipes: poco/1.8.1 poco/1.9.3 poco/1.9.4 poco/1.10.0 poco/1.10.1 这里需要指定--remote=conan-center，否则conan将从本地cache中查找。 选择一个Poco的版本，可以查看它的包描述。 $ conan inspect poco/1.9.4 name: poco version: 1.9.4 url: https://github.com/conan-io/conan-center-index homepage: https://pocoproject.org license: BSL-1.0 author: None description: Modern, powerful open source C++ class libraries for building network- and internet-based applications that run on desktop, server, mobile and embedded systems. topics: ('conan', 'poco', 'building', 'networking', 'server', 'mobile', 'embedded') generators: cmake exports: None exports_sources: CMakeLists.txt short_paths: False apply_env: True build_policy: None revision_mode: hash settings: ('os', 'arch', 'compiler', 'build_type') options: cxx_14: [True, False] enable_apacheconnector: [True, False] enable_cppparser: [True, False] enable_crypto: [True, False] [...] default_options: cxx_14: False enable_apacheconnector: False enable_cppparser: False enable_crypto: True [...] 从如上包描述中，也可以大致看出来conan的包的元信息能够描述的内容以及能力。 接下来，可以为md5程序指定依赖以及构建了。在目录下创建一个conanfile.txt文件，描述如下： [requires] poco/1.9.4 [generators] cmake 这里构建指定的是cmake，所以需要提前预装cmake工具。在过程中将会产生一个conanbuildinfo.cmake文件，包含一些列CMake变量，指定了构建的include路径、库名称等，用于构建过程。 下一步，我们将要安装以来的包，以及为其产生用于构建的各种信息文件。 注意，如果你使用的GCC版本大于等于5.1，Conan为了后向兼容设置compile.libcxx为老的ABI，你需要使用下面的命令作以修改： $ conan profile new default --detect # Generates default profile detecting > GCC and sets old ABI $ conan profile update settings.compiler.libcxx=libstdc++11 default # Sets libcxx to C++11 ABI 执行以下命令安装依赖： $ mkdir build && cd build $ conan install .. 通过打印输出可以看到，Conan除了安装了直接依赖的Poco，还安装了间接依赖的OpenSSL和zlib库。同时它为我们的构建系统产生了conanbuildinfo.cmake文件。 现状，为MD5程序创建自己的构建文件。如下创建CmakeLists.txt文件，包含conan自动生成的conanbuildinfo.cmake文件。 cmake_minimum_required(VERSION 2.8.12) project(MD5Encrypter) add_definitions(\"-std=c++11\") include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) conan_basic_setup() add_executable(md5 md5.cpp) target_link_libraries(md5 ${CONAN_LIBS}) 现在可以构建并运行最终的MD5计算器程序了。 $ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release $ cmake --build . ... [100%] Built target md5 $ ./bin/md5 c3fcd3d76192e4007dfb496cca67e13b 依赖的安装 运行conan install命令，帮我们下载了依赖的Poco程序包，及其间接依赖的OpenSSL以及Zlib库。Conan自动根据我们的平台下载合适的二进制（Conan首次运行时会自动检测平台配置）。在这个过程中，conan会在当前目录下（示例中的build目录）创建conanbuildinfo.cmake文件，在该文件中能够看到各种CMake变量；还有一个conaninfo.txt文件，保存了各种配置、依赖和构建选项信息。 注意： Conan会自动根据对系统的检测结果（OS、编译器、架构等等）产生默认的profile配置。这些信息会打印在conan install的开始。强烈建议你review下这些选项，然后根据需要进行调整。具体调整方式可以参考这里。 了解conan install的过程是很重要的。当命令执行时，/.conan/profiles/default文件里面的配置将会被命令行程序应用。 举个例子，当命令conan install .. --settings os=\"Linux\" --settings compiler=\"gcc\"运行时，一些步骤将被执行： 检查对应的包的说明文件（例如 poco/1.9.4）是否已经在本地缓存中存在。如果第一次运行conan，缓存会是空的； 从远程的中央仓查找包的说明文件。默认从conan-center查找，这个可以改。 如果中央仓中有包的说明文件，conan客户端下载以及将其存在缓存中； 根据包的说明文件以及输入配置（Linux，GCC），conan在本地缓存查找与包对应的二进制； 如果本地缓存没有，conan在中央仓查找对应的二进制包，并下载； 最终，根据[generator]的描述，将为构建系统产生需要的文件； Conan Server上维护了针对主流编译器和版本的二进制包，如果特定配置的二进制包不存在conan将会抛出一个错误。你可以使用conan install .. --build=missing来从源码构建你需要的二进制包，当然这需要你要的二进制配置被包的说明文件所支持。 按照自定义配置构建包 在这个例子中，我们使用conan检查的系统默认配置做的构建。 conan install运行前需要先定义好profile，conan会自动检测系统（编译器、体系架构等等）并将对应的profile存在~/.conan/profiles/default文件中。你可以根据你的需要编辑这个文件，配置新的一系列profile。 如果我们配置了一个32-bit的GCC构建类型的profile，起名为gcc_x86。我们可以如下运行： conan install .. --profile=gcc_x86 提醒：强烈建议通过conan config install命令使用和管理Profiles 同样，用户可以通过conan install的--setting参数更改profile中的部分配置。例如，想要构建32位的版本，也可以使用如下命令： conan install .. --settings arch=x86 上面的命令将会使用--settings arch=x86配置替代默认profile中的配置，然后在本地安装一个不同的二进制包。 为了能够使用32位的二进制包，你还需要调整你的本地工程构建配置： 对于windows，将CMake的构建改为调用Virual Studio 14； Linux上，需要在CMakeLists.txt中加入-m32；如 SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -m32\")，包括加入到CMAKE_C_FLAGS, CMAKE_SHARED_LINK_FLAGS and CMAKE_EXE_LINKER_FLAGS。我们随后会展示这件事也可以用conan自动的做。 在macOS上，你需要定义-DCMAKE_OSX_ARCHITECTURES=i386 查看依赖 获取下来的包存在本地缓存（一般在.conan/data目录下），以供别的工程复用。这样在没有网络的时候依然可以清空工程继续工作。搜索本地缓存的包用该命令 conan search \"*\"。 查看一个二进制包的细节可以用conan search poco/1.9.4@。 包末尾的@符号用于指定特定的版本，否则conan会以模式搜索的方式，返回匹配“poco/1.9.4”的所有包。 可以通过conan info 命令查看当前工程的所有依赖包的细节，这个命令需要在指定工程conanfile.txt文件所在的路径。 可以使用conan info --graph=file.html来生成依赖图，可以指定Dot或者HTML格式。 查找包 Conan默认配置的从Conan Center查找和安装包。 你可以使用如下命令在Conan Center中查找包： $ conan search \"open*\" --remote=conan-center Existing package recipes: openal/1.18.2@bincrafters/stable openal/1.19.0@bincrafters/stable openal/1.19.1 opencv/2.4.13.5@conan/stable opencv/3.4.3@conan/stable opencv/3.4.5@conan/stable opencv/4.0.0@conan/stable opencv/4.0.1@conan/stable opencv/4.1.0@conan/stable opencv/4.1.1@conan/stable openexr/2.3.0 openexr/2.3.0@conan/stable openexr/2.4.0 openjpeg/2.3.0@bincrafters/stable openjpeg/2.3.1 openjpeg/2.3.1@bincrafters/stable openssl/1.0.2s ... 可以看到上面搜索出来的二进制包，有的以@加一个后缀结束。这个后缀user/channel字段，一般用于组织或个人更改了包的配置后，用于和原包做区分的（在包名和版本号之外）。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"04-using-package.html":{"url":"04-using-package.html","title":"使用包","keywords":"","body":"使用包 本节一起看看如何使用Conan建立工程以及管理依赖。 安装依赖 前面通过conan install命令下载Poco库并构建了一个案例。 在这个例子中，打开生成的conanbuildinfo.cmake文件，将会发现里面有很多CMake的变量声明。例如CONAN_INCLUDE_DIRS_ZLIB，描述了zlib库头文件的包含路径，而CONAN_INCLUDE_DIRS定义了所有依赖的头文件的包含路径。 如果检查这些变量定义的全路径，会发现都位于目录下。这些路径构成了本地缓存，所有的包配置以及二进制文件都存储在这里，因此相同的包不会重复下载。通过conan search可以查看本地缓存，通过conan remove可以从缓存删除指定的包。 跳转到conanbuildinfo.cmake文件中指定的目录下，你可以找到每个包的头文件和生成的库文件。 当在命令行执行conan install pocp/1.9.4@的时候，Conan会将Poco包以及它的依赖包（openssl/1.0.2t and zlib/1.2.11）下载到本地缓存目录，并会在安装过程中打印出安装目录。相比一个一个的安装依赖，我们推荐使用conanfile.txt文件描述依赖并整体安装。下面介绍conanfile.txt文件的格式。 Requires conanfile.txt文件的[requires]段用来描述依赖，例如： [requires] mypackage/1.0.0@company/stable 在这个例子中： mypackage是依赖的包的名字； 1.0.0表示包的版本。版本可以是任何的字符串，不一定非得是数字。例如可以用“develop”或“master”。另外包也可以被覆盖，所以可以使用“nightly”或者“weekly”表示它是周期产生的； company代表包的所有者。这个字段可以作为包的命名空间，允许不同的用户有同名的包。 stable表示包的渠道（channel）。这个字段可以为相同的包提供一种可替换的版本，可以使用任何的字符串。例如常用的“stable”或者“testing”。也可以用于表示包为不同的目的做的修订（例如：包的版本不变，但是包的配置修改了）； @符号后面的是可选的，官方将其叫做user/chanel描述。这是个实验特性，未来可能会变化。如果包创建和上传的时候没有指定user和channel描述，当我们指定依赖的时候就忽略user/chanel。如下： [requires] packagename/1.2.0 [requires]后面的依赖可以有多项，而且还可以覆盖依赖包的依赖。比如本例中，Conan安装了Poco以及所有它间接依赖的包（openssl/1.0.2t，zlib/1.2.11）。 现在假设OpenSSL库有新的版本发布，Conan对应有了新的包。我们不需要等着poco项目更新一个使用最新OpenSSL的新的POCO包。 我们可以简单的在[require]下面指明新的OpenSSL版本即可： [requires] poco/1.9.4 openssl/1.0.2u openssl/1.0.2u版本将会覆盖POCO中原先依赖的openssl/1.0.2t。 再比如，我们想要试试最新的zlib库的alpha特性，我们可以将该库替换成其它用户或者渠道（channel）的。 [requires] poco/1.9.4 openssl/1.0.2u zlib/1.2.11@otheruser/alpha Generators Conan从conanfile.txt中的[generator]段中读取配置，然后为每个generator生成文件临时文件。这些文件一般创建在独立的“build”目录下，不需要版本控制。这些文件是按照conan install运行时指定的配置（Debug/Release, x86/x86_64等等）生成的，如果配置变了，这些文件响应的也会变化。 关于generator更详细的信息，可以访问官方generator的文档。 Options 我们看到在执行conan install的时候可以指定配置。例如conan install .. -s build_type=Debug。这里指定的一般都是客户机器上的项目级别的配置，一般没法在包配置中指定默认值。例如，在包配置中指定使用“Visual Studio”作为默认编译期就不合理，因为类似这些配置最好由最终用户指定，否则对于在linux工作上的用户就不友好。 但是包配置中的[options]最好用于指定包普遍适用的配置，以及指定默认值。例如一个包可以指定默认为静态链接，这样用户一般情况就不用再指定了。 可以使用类似conan get poco/1.9.4@的命令查看指定包的的options。也可以通过conan inspect命令，如下： $ conan inspect poco/1.9.4@ -a=options $ conan inspect poco/1.9.4@ -a=default_options 我们可以在使用中修改某个包的默认配置。例如指定poco为动态链接： [requires] poco/1.9.4 [generators] cmake [options] poco:shared=True # PACKAGE:OPTION=VALUE openssl:shared=True 下来就可以按照新的配置在build目录下构建工程了（如果不是Windows用户的修改下面命令中指定的CMake Generator）。 $ conan install .. $ cmake .. -G \"Visual Studio 14 Win64\" $ cmake --build . --config Release 除了在conanfile.txt中修改options，也可以直接在命令行中指定： $ conan install .. -o poco:shared=True -o openssl:shared=True # or even with wildcards, to apply to many packages $ conan install .. -o *:shared=True 随后Conan将会安装这些包的动态库二进制文件，最终的md5计算器程序构建时将会链接这些动态库。最后，我们执行md5程序： $ ./bin/md5 意外的是程序出错了，提示没有找到动态库。动态库是在运行时查找的，所以当我们运行md5程序的时候，它由于找不到动态库而出错。 我们可以通过命令查看可执行程序依赖的动态库： $ cd bin $ objdump -p md5 ... Dynamic Section: NEEDED libPocoUtil.so.31 NEEDED libPocoXML.so.31 NEEDED libPocoJSON.so.31 NEEDED libPocoMongoDB.so.31 NEEDED libPocoNet.so.31 NEEDED libPocoCrypto.so.31 NEEDED libPocoData.so.31 NEEDED libPocoDataSQLite.so.31 NEEDED libPocoZip.so.31 NEEDED libPocoFoundation.so.31 NEEDED libpthread.so.0 NEEDED libdl.so.2 NEEDED librt.so.1 NEEDED libssl.so.1.0.0 NEEDED libcrypto.so.1.0.0 NEEDED libstdc++.so.6 NEEDED libm.so.6 NEEDED libgcc_s.so.1 NEEDED libc.so.6 Imports 动态库需要加入到系统路径中才能被找到，Linux上一般在环境变量LD_LIBRARY_PATH中指定，OSX系统中则是DYLD_LIBRARY_PATH，而Windows则是加入系统PATH中。一般情况下将动态库拷贝到这些路径下，就可以被查找到。但是Conan尽量避免与这些不同OS的环境配置相关。 在Windows和OSX下，最简单的方式是将动态库拷贝到可执行程序所在的目录下，这样它们就可以被可执行程序找到，而不用去修改系统路径。 利用conanfile.txt的[import]段可以自动完成这件事。例如： [requires] poco/1.9.4 [generators] cmake [options] poco:shared=True openssl:shared=True [imports] bin, *.dll -> ./bin # Copies all dll files from packages bin folder to my \"bin\" folder lib, *.dylib* -> ./bin # Copies all dylib files from packages lib folder to my \"bin\" folder 这个例子中指定将包的所有dll和dylib文件拷贝到当前工程的bin目录下。可以打开本地缓存（~/.conan/data）看看，一般包结构里面*.dll将会在\"/bin\"目录下，而其它的库文件则在\"/lib\"目录下。 增加了import配置后，再次在build目录下执行conan install ..，随后再运行程序./bin/md5，可以发现程序运行正常了。 查看\"build/bin\"目录，可以看到需要的动态库被拷贝在了这里。 官方认为[import]段是一个更通用的将库引入当前工程的方式。用这个方式可以把可执行程序要的其它依赖拷贝到bin目录下，例如声音、图片、为测试准备的静态文件等等。 使用profiles 目前我们一直使用的默认配置进行构建，配置存在~/.conan/profiles/default文件中。 但是，对一个大的工程，配置会越来越复杂，很难用一套配置满足所有需求。我们需要有种简单的方式在多种配制间切换。一种简单的方式是定义多个profile。 一个profile文件包含预定义好的settings, options, environment variables 以及build_requires。例如： [settings] setting=value [options] MyLib:shared=True [env] env_var=value [build_requires] Tool1/0.1@user/channel Tool2/0.1@user/channel, Tool3/0.1@user/channel *: Tool4/0.1@user/channel Options可以指定通配符，表示将一个选项应用于许多的包。例如： [options] *:shared=True 以下是个clang_3.5的完整的例子： [settings] os=Macos arch=x86_64 compiler=clang compiler.version=3.5 compiler.libcxx=libstdc++11 build_type=Release [env] CC=/usr/bin/clang CXX=/usr/bin/clang++ Profile文件可以存在默认的profile的目录下，或者其它工程目录下任何位置。使用profile指定的配置，可以通过命令行参数指定profile文件，例如： $ conan create . demo/testing -pr=clang_3.5 继续使用Poco的例子。我们可以定义一个profile文件保存各种目标配置，然后在install的时候通过命令行参数传递给conan。 一个将依赖安装为动态库以及debug模式的profile文件(debug_shared)如下： include(default) [settings] build_type=Debug [options] poco:shared=True poco:enable_apacheconnector=False openssl:shared=True 然后可以用下面的命令安装依赖： $ conan install .. -pr=debug_shared 我们还能够创建一个profile文件（poco_clang_3.5）使用另外一个编译器版本，并将其存在工程目录下，例如： include(clang_3.5) [options] poco:shared=True poco:enable_apacheconnector=False openssl:shared=True 然后指定安装依赖使用这个新的profile： $ conan install .. -pr=../poco_clang_3.5 可以给命令行传入多个profile，应用的配置将会是组合多个profile后的结果，并且根据profile文件的顺序： $ conan install .. -pr=../poco_clang_3.5 -pr=my_build_tool1 -pr=my_build_tool2 Profiles的reference文档中有其完整的介绍，它可以为指定的库指定对应的编译器和环境变量等。还有一个命令conan profile可以用来查看和管理profile。还可以使用命令conan config install命令来共享和安装profile。 工作流 本节总结了用户使用conan与其它工具结合安装和消费已存在的包的一般工作流程。如论是处理单配置项目，还是多配置项目，都推荐你在项目根目录中使用conanfile（.py或.txt）来配置项目。 单配置 当你的工程使用单一配置时，conanfile如我们前面示例中的那样，会相对比较简单。在前面的例子中，通过conan install ..在build目录下产生了conaninfo.txt以及conanbuildinfo.cmake文件用于支持项目构建。注意build目录是一个临时目录，不需要对其进行版本管理。 独立于源码外的build目录（Out-of-source builds）也是支持的。如下例子： $ git clone git@github.com:conan-io/examples $ cd libraries/poco $ conan install ./md5 --install-folder=md5_build 这将产生如下的目录结构： md5_build conaninfo.txt conanbuildinfo.txt conanbuildinfo.cmake md5 CMakeLists.txt # If using cmake, but can be Makefile, sln... README.md conanfile.txt md5.cpp 现在你可以如下构建： $ cd md5_build $ cmake ../md5 -G \"Visual Studio 15 Win64\" # or other generator $ cmake --build . --config Release $ ./bin/md5 > c3fcd3d76192e4007dfb496cca67e13b 通过上面的方式我们创建了一个和工程源码分离的build目录，这样的好处是我们可以容易的对各种配置进行试验，我们清空某一个build不会影响到别的build目录。例如我们可以增加一个Debug类型的build目录： $ rm -rf * $ conan install ../md5 -s build_type=Debug $ cmake ../md5 -G \"Visual Studio 15 Win64\" $ cmake --build . --config Debug $ ./bin/md5 > c3fcd3d76192e4007dfb496cca67e13b 多配置 你可以在源码内或者源码外管理多个不同的配置，并且可以在它们之间切换而不用每次重新调用conan install。当然如果已经执行过conan install，然后在本机其它项目中使用相同的配置，再次执行conan install将会非常快，因为相关的包已经被安装在本地缓存中了（而不是某个项目内部）。 $ git clone git@github.com:conan-io/examples $ cd libraries/poco $ conan install md5 -s build_type=Debug -if md5_build_debug $ conan install md5 -s build_type=Release -if md5_build_release $ cd md5_build_debug && cmake ../md5 -G \"Visual Studio 15 Win64\" && cd ../.. $ cd md5_build_release && cmake ../md5 -G \"Visual Studio 15 Win64\" && cd ../.. 注意，上面的例子中--install-folder被缩写为-if。 现在，项目目录将会如下： md5_build_debug conaninfo.txt conanbuildinfo.txt conanbuildinfo.cmake CMakeCache.txt # and other cmake files md5_build_release conaninfo.txt conanbuildinfo.txt conanbuildinfo.cmake CMakeCache.txt # and other cmake files example-poco-timer CMakeLists.txt # If using cmake, but can be Makefile, sln... README.md conanfile.txt md5.cpp 现在你可以选择到任何一个配置目录下执行构建，因为conan将具体不同的配置文件生成在不同的目录下。 $ cd md5_build_debug && cmake --build . --config Debug && cd ../.. $ cd md5_build_release && cmake --build . --config Release && cd ../.. 注意这里需要修改例子中代码中的CMake文件的include()，加上cmake二进制的目录宏，否则cmake构建的时候将找不到对应的conanbuildinfo.cmake文件。 include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) conan_basic_setup() 调试包 要能够调试一个包的源码，调试器需要能找到源码以及可供调试的信息（Visual Studio中的pdb文件，对于MAC和Unix系统，位于库本身中）。 一般情况下，Conan的包中没有包含调试信息文件；就算包含，每个用户的本地的缓存路径也可能不同。而且一般包都是由CI（持续集成）服务器自动构建的，供调试的信息的路径一般也和开发者机器上的不一样。 这里一个做法是在开发者的机器上直接编译一个可供调试的包，在Conan下这很简单： conan install --build --profile 这个命令将会触发库的构建发生在开发者的机器上，因此二进制指向的源码目录就是确定的，调试器将能够根据调试信息找到源码。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"05-creating-packages.html":{"url":"05-creating-packages.html","title":"创建包","keywords":"","body":"创建包 本章主要关于如何创建、构建以及测试你的包。 起步 我们从一个已经存在的代码库https://github.com/conan-io/hello开始学习怎么创建conan包。可以看到这是一个很简单的“hello world” C++库，它使用CMake构建出来一个库可执行程序。当前它和Conan没有任何关系。 虽然当前示例使用github作为包的源码仓，但是Conan也支持选择其它代码源，例如从网络上下载压缩包（*.zip或者tar包）。 创建包配置 首先，我们为包的配置创建一个目录，然后使用conan new命令，帮我们生成初始的配置文件： $ mkdir mypkg && cd mypkg $ conan new Hello/0.1 -t 现在我们的目录下有这些文件： conanfile.py test_package CMakeLists.txt conanfile.py example.cpp 顶级目录下的conanfile.py文件是主要的包配置文件，用于定义一个包。下面的test_package目录，站在消费者的角度去链接我们将要创建的包，用于测试我们的包是否创建OK。 顶层的conanfile.py文件内容如下： from conans import ConanFile, CMake, tools class HelloConan(ConanFile): name = \"Hello\" version = \"0.1\" license = \"\" url = \"\" description = \"\" settings = \"os\", \"compiler\", \"build_type\", \"arch\" options = {\"shared\": [True, False]} default_options = {\"shared\": False} generators = \"cmake\" def source(self): self.run(\"git clone https://github.com/conan-io/hello.git\") # This small hack might be useful to guarantee proper /MT /MD linkage # in MSVC if the packaged project doesn't have variables to set it # properly tools.replace_in_file(\"hello/CMakeLists.txt\", \"PROJECT(MyHello)\", '''PROJECT(MyHello) include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) conan_basic_setup()''') def build(self): cmake = CMake(self) cmake.configure(source_folder=\"hello\") cmake.build() # Explicit way: # self.run('cmake %s/hello %s' # % (self.source_folder, cmake.command_line)) # self.run(\"cmake --build . %s\" % cmake.build_config) def package(self): self.copy(\"*.h\", dst=\"include\", src=\"hello\") self.copy(\"*hello.lib\", dst=\"lib\", keep_path=False) self.copy(\"*.dll\", dst=\"bin\", keep_path=False) self.copy(\"*.so\", dst=\"lib\", keep_path=False) self.copy(\"*.dylib\", dst=\"lib\", keep_path=False) self.copy(\"*.a\", dst=\"lib\", keep_path=False) def package_info(self): self.cpp_info.libs = [\"hello\"] 这是一个完整的包配置文件。在进入细节前，我们看看基本的内容： settings字段定义了能产生包的不同二进制的配置有哪些。本例中，任何对\"os\", \"compiler\", \"build_type\", \"arch\"的改变都会产生一个不同的二进制包。Conan利用一个配置文件加上具体不同的配置值产生不同的二进制包。 注意，在交叉编译情况下，依据包的配置文件构建包的平台和最终代码运行的平台是不同的（self.settings.os和self.settings.arch）。因此如果你要根据构建机器选择不同的构建方式，你需要类似如下： def build(self): if platform.system() == \"Windows\": cmake = CMake(self) cmake.configure(source_folder=\"hello\") cmake.build() else: env_build = AutoToolsBuildEnvironment(self) env_build.configure() env_build.make() 包的配置文件可以定义包最终要生成静态还是动态库的选项，具体使用shared，它默认被设成了False； source()方法用来执行git clone，从Github上获取代码。其它的代码源，例如下载源码的zip文件也是支持的。事实上通过python代码，对源码的任何处理都是可以的，例如从某一个branch或者tag下载代码，或者对源码应用patch。本例中，我们为已经代码中已经存在的CMake文件增加了两行代码，用于保证二进制兼容性。关于这点更详细的内容随后会再进一步解释。 build()方法用于配置项目的构建过程。本例演示了通过CMake命令构建源码的过程。这里你也可以使用其它构建工具，如make、MSBuild、SCons或者其它构建工具，具体可以查看这里； package()方法将所有的发布物（头文件和libs）从build目录下拷贝到最后的包目录下； 最后package_info()函数定了用户使用这个包的时候需要链接名为hello的库文件。其它的信息如include或者lib文件路径等都可以定义在这里。这些信息将会被Conan的generator使用并写入生成的文件中(conanbuildinfo.cmake)，供最终用户使用。 更多关于conanfile.py文件的细节建议查看该文件的说明手册https://docs.conan.io/en/latest/reference/conanfile.html#conanfile-reference。 test_package目录 test_folder目录不是用来做单元测试或者集成测试的，它是用来测试我们要生成的包是否能够正常被使用。 test_folder目录下的example.cpp和CMakeLists.txt文件并没有什么特别的，但同时也存在一个包配置文件：test_package/conanfile.py。这个包配置文件类似于我们前面的conanfile.txt，用于扮演一个包的消费者。 from conans import ConanFile, CMake import os class HelloTestConan(ConanFile): settings = \"os\", \"compiler\", \"build_type\", \"arch\" generators = \"cmake\" def build(self): cmake = CMake(self) cmake.configure() cmake.build() def imports(self): self.copy(\"*.dll\", dst=\"bin\", src=\"bin\") self.copy(\"*.dylib*\", dst=\"bin\", src=\"lib\") def test(self): os.chdir(\"bin\") self.run(\".%sexample\" % os.sep) 这个conanfile.py文件具有以下特点： 不包含name和version字段，因为它只是用来测试，不发布包； 同样也不需要package()和package_info()函数； test()函数指明了我们需要跑的二进制程序； import()函数将所有共享库拷贝进当前的bin目录下。这样当test()调动example可执行程序的时候，它将能够执行动态链接并执行； 注意：在test_package目录下的conanfile.py中并不需要显示的在requires表达需要依赖被测试的`Hello/0.1@demo/testing'包，因此这个依赖Conan会在执行的时候自动加上。如果你选择显示声明这个依赖，也会正常执行，不过你需要记住一旦你修改了发布包的版本或者user和channel，你得记着在test_package下修改依赖描述。 创建和测试包 现在，你可以使用当前的配置创建和测试包了： $ conan create . demo/testing ... Hello world! 如上，输出“Hello world！”则说明运行正常。 在上面的conan create命令做了如下事宜： 从用户的目录(mypkg)导出conanfile.py到本地缓存； 安装包，从源码构建； 在test_package目录下创建一个临时的build目录； 执行'conan install ..'命令，安装test_package/conanfile.py中描述的依赖；（注意，对hello包的依赖时conan自动为test_package加入的）； 通过调用test_package/conanfile.py中的build()和test()函数，执行example的构建和运行。 对于conan create命令，它和运行下面一些列命令式等价的： $ conan export . demo/testing $ conan install Hello/0.1@demo/testing --build=Hello # package is created now, use test to test it $ conan test test_package Hello/0.1@demo/testing 你可以为conan create传入不同的参数来执行不同的构建： $ conan create . demo/testing -s build_type=Debug $ conan create . demo/testing -o Hello:shared=True -s arch=x86 $ conan create . demo/testing -pr my_gcc49_debug_profile ... $ conan create ... 创建包的时候也可以忽略user/channel字段，直接conan create .。 包配置文件中的 settings 和 Options 的区别 我们在包配置中的setting中指定了os,arch以及compiler。注意到上面的示例中包配置文件汇总还有一个shared的option（options = {\"shared\" : [True, False]}）。那么settings和options之间的区别是什么呢？ Settings是全工程级别的配置，它会应用到所有构建的工程。例如操作系统和体系架构一般对于一个工程所有依赖的包的构建来说都是相同的。为Windows程序链接一个linux的库这种交叉的情况是没有的。 另外setting没有包级别的默认值。一个包不可能配置os的默认值为Windows，os参数是包构建的时候根据实际环境传入的。 使用包的工程可以配置settings，你可以在~/.conan/settings.yml文件中查看当前支持的所有settings的种类以及值。当然你也可以修改这个文件，增加新的settings分类和允许的值。具体参考https://docs.conan.io/en/latest/extending/custom_settings.html#custom-settings。 Options用来描述包级别的配置。包是静态还是动态链接（Static和Shared）不应该是一个针对所有包的setting配置，所以需要是options。一些包可能是纯头文件的包，还有一些可能仅仅是数据、或者可执行程序，因此包可以定义任意它们需要的options。 根据需要在包的配置文件中定义所有包支持的options，包含它们的名字和可选的值，以及默认值。 注意上述情况有些例外，比如可以通过命令行为某一个包指定特殊的settings配置：conan install . -s MyPkg:compiler=gcc -s compiler=clang ..。这将会导致使用gcc构建MyPkg并用clang构建其余所有依赖的包； 也可以通过命令行参数修改所有包的option，例如conan install . -o *:shared=True，将所有包的shared改为True。 包配置文件和源码在不同的代码仓 前面的例子中，我们从一个外部代码仓获取包的源码，这种情况一般用于对第三方代码库制作包。 有两种不同的从外部代码仓获取源码的方式： 使用source()函数： from conans import ConanFile, CMake, tools class HelloConan(ConanFile): ... def source(self): self.run(\"git clone https://github.com/conan-io/hello.git\") ... 你也可以使用tools.Git类： from conans import ConanFile, CMake, tools class HelloConan(ConanFile): ... def source(self): git = tools.Git(folder=\"hello\") git.clone(\"https://github.com/conan-io/hello.git\", \"master\") ... 使用conanfile的scm属性（注意：这是个实验特性）； from conans import ConanFile, CMake, tools class HelloConan(ConanFile): scm = { \"type\": \"git\", \"subfolder\": \"hello\", \"url\": \"https://github.com/conan-io/hello.git\", \"revision\": \"master\" } ... Conan将会从scm url检出scm version对应的代码。source()方法在代码检出后仍然会被调用，因此你仍然可以在里面做一下源码检出后的patch活动。 包配置文件和源码在同一个代码仓 如果我们是在给自己开发的代码写包配置文件，那么配置文件和源码在一起就会比较方便。具体有两种方式来做： 使用exports_sources属性，将包的配置文件和源码快照一起导出； 使用scm属性从对应的远端代码仓自动获取包源码的指定commit版本； 使用exports_sources导出包配置和源码 如果我们希望包配置和源码在一个代码仓并将源代码也打包发布，这将是一个很方便的做法。 首先，我们在当前目录下使用命令conan new Hello/0.1 -t -s自动创建初始的代码和包配置文件。 可见自动创建了src目录，并在下面初始化了hello的源码。而启动创建的conanfile.py如下： from conans import ConanFile, CMake class HelloConan(ConanFile): name = \"Hello\" version = \"0.1\" license = \"\" url = \"\" description = \"\" settings = \"os\", \"compiler\", \"build_type\", \"arch\" options = {\"shared\": [True, False]} default_options = {\"shared\": False} generators = \"cmake\" exports_sources = \"src/*\" def build(self): cmake = CMake(self) cmake.configure(source_folder=\"src\") cmake.build() # Explicit way: # self.run('cmake \"%s/src\" %s' % (self.source_folder, cmake.command_line)) # self.run(\"cmake --build . %s\" % cmake.build_config) def package(self): self.copy(\"*.h\", dst=\"include\", src=\"src\") self.copy(\"*.lib\", dst=\"lib\", keep_path=False) self.copy(\"*.dll\", dst=\"bin\", keep_path=False) self.copy(\"*.dylib*\", dst=\"lib\", keep_path=False) self.copy(\"*.so\", dst=\"lib\", keep_path=False) self.copy(\"*.a\", dst=\"lib\", keep_path=False) def package_info(self): self.cpp_info.libs = [\"hello\"] 这个和我们前面的例子的文件有两个重要的不同： 增加了exports_sources字段，指示Conan将本地src目录下所有文件导出到包里； 去除了source()方法，因为不需要从外部下载代码或者对代码做额外的特殊处理； 因为如下两行代码已经被加到了源码的CMake文件中了，所以包的conanfile.py中也不必再去修改源码的CMake文件了。 include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) conan_basic_setup() 如下，可以创建一个包，并在版本后加上user/channel属性为 “demo/testing”: $ conan create . demo/testing ... Hello/0.1@demo/testing test package: Running test() Hello world! 使用scm属性从远端仓库中下载对应commit的代码（注意，这是个实验特性） 可以在使用scm属性的时候将url和revision字段设置为auto，这样当导出包配置文件的时候（调用conan create时），Conan将会自动捕获当前代码对应的远端仓库以及提交commit： import os from conans import ConanFile, CMake, tools class HelloConan(ConanFile): scm = { \"type\": \"git\", # Use \"type\": \"svn\", if local repo is managed using SVN \"subfolder\": \"hello\", \"url\": \"auto\", \"revision\": \"auto\", \"password\": os.environ.get(\"SECRET\", None) } ... 当你将conanfile.py提交到代码仓的时候，文件中的auto会被保留。但是当你将代码导出到Conan的本地缓存的时候，conanfile.py中的auto值将会被conan捕获并存在一个conandata.yml文件中（具体依赖“~/.conan/conan.conf”中的“scm_to_conandata”配置）。 如果“scm_to_conandata”配置为不使能（Conan v1.x默认为不使能），Conan将会直接修改connanfile.py，并将其对应属性的值存在一个纯文本文件中；当向conan远程库上传包配置的时候，conan将会将包配置文件中的值进行替换并提交； import os from conans import ConanFile, CMake, tools class HelloConan(ConanFile): scm = { \"type\": \"git\", \"subfolder\": \"hello\", \"url\": \"https://github.com/conan-io/hello.git\", \"revision\": \"437676e15da7090a1368255097f51b1a470905a0\", \"password\": \"MY_SECRET\" } ... 如果“scm_to_conandata”使能，这些auto的值将会被存在conandata.yml文件中，并在导出包配置的时候自动更新； 如果从源码构建包，Conan需要在运行source()方法（如果定义了的话）前，获取url/commit对应的代码。 由于scm属性是有代码运算的，因此你也可以写复杂的计算逻辑，为其计算合理的值。 import os from conans import ConanFile, CMake, tools def get_remote_url(): \"\"\" Get remote url regardless of the cloned directory \"\"\" here = os.path.dirname(__file__) svn = tools.SVN(here) return svn.get_remote_url() class HelloConan(ConanFile): scm = { \"type\": \"svn\", \"subfolder\": \"hello\", \"url\": get_remote_url(), \"revision\": \"auto\" } ... 提醒：conan create或者conan export命令执行时，Conan将会把当前工程的源码导出到本地缓存，但是这时你可能还没有commit代码以及将其push到远端代码仓中。这个特性相比每次从代码仓中克隆代码要快，但是当你的scm特性中有auto字段且你存在没有commit的代码变动时，Conan还是会给一个告警信息。你可以使用--ignore-dirty配置忽略告警，但是当你执行conan upload命令的时候仍不能上传包，除非你强制使用conan upload --force上传auto字段没有被正确替换的包。 打包已存在的二进制 在有些特定的场景下，需要使用已经存在二进制来构建conan包。 当你不能从源码构建包，比如你只有别人构建好的二进制； 当你在开发包的过程中，只想将二进制导入到本地缓存，以避免调用conan create引起的重新构建。这个方法让你使用IDE或者运行conan build命令过程中保留你的构建缓存。 打包预编译的二进制 打包预编译的二进制文件的话，包配置文件的build()方法，不能够写代码从用户目录拷贝文件，因为发包后无法可复现的从用户目录再次拷贝二进制文件。这里，Conan提供了conan export pkg命令。 打包二进制，仍然是需要包配置文件的，但是文件很简单，只用包含基本的包的元信息即可。 $ conan new Hello/0.1 --bare 于是，会在本地缓存创建如下的包配置文件： class HelloConan(ConanFile): name = \"Hello\" version = \"0.1\" settings = \"os\", \"compiler\", \"build_type\", \"arch\" def package(self): self.copy(\"*\") def package_info(self): self.cpp_info.libs = self.collect_libs() 这个配置文件中的package_info()函数将会从包中扫描所有的文件，为最终用户提供可以链接的库名。默认的package_info()会按照如下规则配置包：头文件在“include”目录下，库文件在“lib”目录下，而其它二进制文件在“bin”目录下。可以自定义package_info()函数实现其它包结构。 包的配置文件依然可以提供options，增加依赖requires，以及做其它配置定制。 基于之前的例子，我们假定当前目录中的lib目录下有构建好的hello的库文件libhello.a，并且与windows MinGW4.9兼容，这时我们可以直接产生一个二进制包： $ conan export-pkg . Hello/0.1@myuser/testing -s os=Windows -s compiler=gcc -s compiler.version=4.9 ... 强烈推荐使用test_package目录对包进行本地测试，如果我们不想从源码构建包，我们需要如下操作： $ conan new Hello/0.1 --bare --test # customize test_package project # customize package recipe if necessary $ cd my/path/to/binaries $ conan export-pkg PATH/TO/conanfile.py Hello/0.1@myuser/testing -s os=Windows -s compiler=gcc -s compiler.version=4.9 ... $ conan test PATH/TO/test_package/conanfile.py Hello/0.1@myuser/testing -s os=Windows -s compiler=gcc -s ... 上述最后两条命令可以针对不同的配置（继续创建其它的二进制包）重复执行。 下载以及打包预编译好的二进制 在需要下载二进制的场景下，需要创建包配置文件，并描述二进制获取的方式（因为这个过程是可重复的）。如下： class HelloConan(ConanFile): name = \"Hello\" version = \"0.1\" settings = \"os\", \"compiler\", \"build_type\", \"arch\" def build(self): if self.settings.os == \"Windows\" and self.settings.compiler == \"Visual Studio\": url = (\"https:///downloads/hello_binary%s_%s.zip\" % (str(self.settings.compiler.version), str(self.settings.build_type))) elif ...: url = ... else: raise Exception(\"Binary does not exist for these settings\") tools.get(url) def package(self): self.copy(\"*\") # assume package as-is, but you can also copy specific files or rearrange def package_info(self): # still very useful for package consumers self.cpp_info.libs = [\"hello\"] 一般情况下，针对不同配置构建出来的二进制是不同的，所以build()函数中需要根据不同的settings从不同的URL上下载。 了解打包过程 手动创建和测试包 我们强烈推荐如前面例子所示，在包下创建test_package目录来测试包，但是这种方式不是强制的。你可以使用conan new命令的时候不带-t参数： $ mkdir mypkg && cd mypkg $ conan new Hello/0.1 这时只会创建一个conanfile.py文件，现在我们可以创建我们的包： $ conan create . demo/testing 这等价于： $ conan export . demo/testing $ conan install Hello/0.1@demo/testing --build=Hello conan install的参数--build可以简写为-b，指定要从源码构建包，参数是包名。其它可选的参数分别有never、missing、cascade以及outdated，具体查看conan install --help。 一旦包被创建，它就可以被消费了。 包的创建过程 理解包在本地缓存中的目录布局以及创建流程对于用好conan是重要的。 每个包在本地缓存中有如下重要的目录： export: 包的配置文件存在这个目录下； export_source: 包配置中exports_sources属性指明的代码将会被拷贝到这里； source: 构建所需要的源码存在这里； build: 从源码执行构建的产物放在这里，如果有多个二进制配置的话，这个目录将会在各自的二进制的子目录下都有； package: 这个目录是最终的包目录。每个二进制配置下都将会有一个。 source和build目录，仅当包是从源码构建出来的才会存在。 打包的过程起始于通过conan export或者conan create将包导出。conanfile.py以及通过export_sources字段指定的文件都将被拷贝到用户的临时缓存中。 接下来，export以及export_source下的文件被拷贝到source目录下，然后source()函数（如果有的话）就会被执行。可以看到所有的二进制共享了共一个source目录。当为不同构建执行代码生成的话，那么代码的操作不应该放到source()函数中，而是应该被放到build()函数中。 对于每个不同的settings和options配置，都将会有一个不同的package ID通过配置的SHA-1哈希算出来。源码将会被拷贝进build/hashXXXfolder，然后build()函数将会被触发。 之后，package()函数被执行，从build/hashXXX目录下将对应的文件拷贝到package/hashXXX目录下。 最后，package_info()用于对用户的构建系统产生所有需要依赖的信息，比如为cmake产生可以包含的conanbuildinfo.cmake文件。另外，imports将会从本地缓存中拷贝需要的生成物到用户空间中。 定义包的ABI(Application Binary Interface)兼容性 一个包配置文件根据settings、options和requires的不同可能会产生N个不同的二进制包。 包配置文件中的setting属性（下例中的os、arch、compiler、build_type）的变化，会导致新的二进制的产生。 class MyLibConanPackage(ConanFile): name = \"MyLib\" version = \"1.0\" settings = \"os\", \"arch\", \"compiler\", \"build_type\" 当这个包通过conanfile.txt或者conanfile.py，或者直接通过命令 conan install MyLib/1.0@user/channel -s arch=x86_64 -s ... 安装的时候，会有以下的过程： Conan将会获得用户输入的settings和options的配置。这些配置会来自命令行或者上次执行conan install是缓存下来的profile值; Conan读取MyLib/1.0@user/channel的包配置，读取settings属性，为其赋上必须的值; 根据当前包的settings以及options还有requires的值，计算一个SHA1的hash值，将其存为二进制包的package ID，例如c6d75a933080ca17eb7f076813e7fb21aaa740f2; Conan将尝试查找c6d75a933080ca17eb7f076813e7fb21aaa740f2二进制包，如果找到则获取它，如果没有找到，可以使用'conan install --build'指示从源码开始构建。 如果包使用不同的settings重新安装，比如使用32位的架构：conan install MyLib/1.0@user/channel -s arch=x86 -s ...，这将会导致一个新的package ID（因为arch的值发生了变化）。其它的变化如不同的编译器、编译器版本、构建类型都会导致新的package ID。 如果开发者使用的包和上传的包的settings设值相同，则计算出来的package ID就会相同，这时可以直接获取已上传的二进制包，而不用重新从源码构建。 Options属性对package ID的影响也是一样的，只不过options是包级别的配置，而且往往可以使用默认值。 稍微要注意的是对于仅有头文件的库，包是不用重新构建的，因为它没有ABI兼容性的问题。包配置对于这类库将会一直产生一个二进制的包，这种包配置文件里的settings和options都比较简单，例如： class MyLibConanPackage(ConanFile): name = \"MyLib\" version = \"1.0\" # no settings defined! 对于这种类型的包，如论用于怎么定义settings、options，最终的package ID都是一样的。 如果我们有一个GCC4.8版本构建的包，它的ABI与GCC 4.9是兼容的，我们不想为这两个编译器版本构建两个不同的二进制，需要怎么做呢？ 自定义package_id() 默认的package_id()直接使用settings和options以及requires中定义的所有依赖的语义化版本来进行计算。 我们可以覆写package_id()来自定义package ID的生成。在该函数内可以访问self.info获取各种配置： self.info.settings包含所有声明的settings，都是一些字符串值，我们可以访问及修改这些值；例如self.info.settings.compiler.version; self.info.options包含了所有声明的options，也都是字符串值。例如self.info.options.shared; self.info对象包含的settings和options的值可以被修改为任意的字符串值。 例如我们家是GCC 4.5到GCC5.0之间的ABI是兼容的，那么可以如下定义包配置文件： from conans import ConanFile, CMake, tools from conans.model.version import Version class PkgConan(ConanFile): name = \"Pkg\" version = \"1.0\" settings = \"compiler\", \"build_type\" def package_id(self): v = Version(str(self.settings.compiler.version)) if self.settings.compiler == \"gcc\" and (v >= \"4.5\" and v 如上，我们将self.info.settings.compiler.version的值修改成了字符串\"GCC version between 4.5 and 5.0\"。这个值不重要，重要的是说明从4.5到5.0版本间使用同一个字符串，这样这些编译器版本最后会生成同样的哈希ID。 现在可以试试，GCC4.5和其它范围内的包的package ID都是相同的： $ conan create . Pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler.version=4.5 ... Requirements Pkg/1.0@myuser/mychannel from local Packages Pkg/1.0@myuser/mychannel:af044f9619574eceb8e1cca737a64bdad88246ad ... $ conan install Pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler.version=4.6 ... Requirements Pkg/1.0@myuser/mychannel from local Packages Pkg/1.0@myuser/mychannel:af044f9619574eceb8e1cca737a64bdad88246ad 而不在范围内的GCC 4.4生成的package ID则是不同的： $ conan install Pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler.version=4.4 ... Requirements Pkg/1.0@myuser/mychannel from local Packages Pkg/1.0@myuser/mychannel:7d02dc01581029782b59dcc8c9783a73ab3c22dd 包的兼容性管理 上面我们通过自定义package_id()的计算来自定义包的二进制兼容性，这这个函数里我们可以根据ABI兼容性在包配置里面调整其它self.info.settings以及self.info.options的值。 你甚至可以删除某些不影响最终二进制的配置： def package_id(self): del self.info.settings.compiler del self.info.options.shared 对于只有头文件的包，settings、options以及依赖等都不影响package ID，则可以如下： def package_id(self): self.info.header_only() 如果动态库链接了静态库，则静态库的二进制相当于“嵌入”到了动态库的二进制中，这意味着静态库的任何改变都需要重新构建动态库。而对于静态库链接静态库以及动态库链接动态库则没有这个问题。 使用shared_library_package_id()来实现package_id()，如下： def package_id(self): self.info.shared_library_package_id() 这样动态库（options中的shared选择设置为Ture）依赖的静态库（options中的shared设置为False或者没有定义）发生变化，Conan将会自动为动态库的包生成不同的package ID。建议对于动态库的包做此设置。 如果你希望将你的依赖全部设置为静态库或者动态库（不出现动态库链接静态库的情况），可以在命令行或者profile中定义*.shared=True，例如： def configure(self): if self.options.shared: self.options[\"*\"].shared = True 默认情况下（discard_build_settings()），当你更改os_build或者arch_build的时候，Conan仍将产生相同的二进制。这是因为os_build和arch_build代表的是Conan运行的机器，但是和二进制最终运行的机器配置os、arch是不同给的。最终二进制运行的机器配置决定了是否生成不同的二进制。 但是当打开self.info.include_build_settings()的时候，Conan将会为不同的os_build和arch_build产生不同的二进制： def package_id(self): self.info.discard_build_settings() # self.info.include_build_settings() 默认情况下（default_std_matching()）,Conan会检测你的编译器对应的默认C++标准，如果不变是不会产生不同的二进制包。 例如你已经构建了gcc 6.1的包，它默认的std是gnu14。这时你指定settings中的compiler.cppstd等于gnu14，Conan是不会产生一个新的二进制包的，因为它和compiler的默认std是一样的。 但是当指定self.info.default_std_non_matching()的时候，一旦你指定compiler.cppstd，即使和编译器默认的一致，Conan也会产生一个新的二进制包。 def package_id(self): self.info.default_std_non_matching() # self.info.default_std_matching() Conan会根据settings和options等算出来的package ID去找合适的二进制包，如果找不到，Conan允许在包配置定制一个package ID的二进制兼容序列，这样Conan将会按照这个序列顺序查找可兼容包。具体做法如下： from conans import ConanFile class Pkg(ConanFile): settings = \"os\", \"compiler\", \"arch\", \"build_type\" def package_id(self): if self.settings.compiler == \"gcc\" and self.settings.compiler.version == \"4.9\": compatible_pkg = self.info.clone() compatible_pkg.settings.compiler.version = \"4.8\" self.compatible_packages.append(compatible_pkg) 如上，当查找gcc 4.9的包失败时，将会按照顺序找到gcc 4.8生成的包来使用。这个方法与我们之前例子中的将gcc 4.5到gcc 5.0之间的编译器配置改为相同字符串的做法self.info.settings.compiler.version = \"GCC version between 4.5 and 5.0\"相比，新的做法下不同gcc版本仍然会构建出不同的二进制包，只是在使用方查找不到的时候才会使用这种兼容性顺序继续查找。 开发者需要保证对应的二进制是真的可以兼容的，对于下例： from conans import ConanFile class Pkg(ConanFile): options = {\"optimized\": [1, 2, 3]} default_options = {\"optimized\": 1} def package_id(self): for optimized in range(int(self.options.optimized), 0, -1): compatible_pkg = self.info.clone() compatible_pkg.options.optimized = optimized self.compatible_packages.append(compatible_pkg) 包配置定义了三种不同的优化级别，对于每种不同的优化级别conan都将产生一个不同的二进制包。在这里开发者设置了optimized=1的二进制包是可以被需要优化级别为2或者3的客户链接使用的，但是优化级别为2的包是不能被优化级别为1的包去使用的。 兼容性是要保证二进制可以互换而没有任何副作用的。例如，如果不同的优化级别的依赖是不同的，这样package_id()对此是无能为力的。因为依赖图谱是在执行package_id()之前生成的，因此兼容性配置无法修改依赖关系。 编译器兼容 有些编译器使用了其它编译器作为基础。例如intel的编译期在windows上使用Visual Studio的，而在linux上使用的是gcc。 在~/.conan/settings.yml中可以看到intel编译器的描述。（你也可以扩展conan支持其它编译器） intel: version: [\"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\"] base: gcc: 你可以使用package_id()方法去根据编译器的base和parent属性去定义包的兼容性。 使用base_compatible()定义base编译器的兼容性。下例中，当使用-s compiler=\"intel\"的时候如果找不到合适的二进制，则会查找base编译器的兼容二进制包。 def package_id(self): if self.settings.compiler == \"intel\": p = self.info.clone() p.base_compatible() self.compatible_packages.append(p) 使用parent_compatible(compiler=\"compiler\", version=\"version\")定义parent编译器的兼容包。下例中如果用户指定visual studio编译器查找包失败，则会搜索intel 16构建的兼容包。 def package_id(self): if self.settings.compiler == \"Visual Studio\": compatible_pkg = self.info.clone() compatible_pkg.parent_compatible(compiler=\"intel\", version=16) self.compatible_packages.append(compatible_pkg) 用下面的方式(不执行self.info.clone())也可以定义兼容包，但是下例中的intel 16构建的包和Visual Studio构建的包的package ID将会相同，这样不利于区分，所以并不太建议这样做。 def package_id(self): if self.settings.compiler == \"Visual Studio\": self.info.parent_compatible(compiler=\"intel\", version=16) 依赖问题 我们假设有两个包：MyOtherLib/2.0 以及 MyLib/1.0 (其中MyLib/1.0依赖于MyOtherLib/2.0)，它们的包配置和二进制都已经创建好并上传能到conan包仓库中了。 现在，新的MyOtherLib/2.1发布了，它有新的包配置和二进制。MyLib/1.0需要修改将将其依赖升级到MyOtherLib/2.1。 现在的问题是，我们是否需要构建新的MyLib/1.0的二进制包？或者已存在的包任然是可用的？ 这里的答案是：得要看情况。 我们假设两个包都是编译成静态库，而且都是通过头文件暴露API的，并且头文件没有变。这时可以不重新构建MyLib/1.0，因为最终的工程会直接和MyLib/1.0以及MyOtherLib/2.1的静态库进行链接。 另一种情况下，MyOtherLib的公开头文件发生了变化，但是并不会影响到MyLib/1.0的二进制（比如新提供的方法MyLib并没有用，或者MyOtherLib是个纯的头文件库），这时MyLib/1.0也是可以不用重新构建的。 但是如果MyOtherLib的实现发生了变化： 假设MyOtherLib中的myadd.h在2.0版本时的实现如下： int addition (int a, int b) { return a - b; } 现在到了2.1版本实现如下： int addition (int a, int b) { return a + b; } 并且addition方法被MyLib/1.0调用了。 这时MyLib/1.0就需要因为其依赖的版本升级而重新构建一个新的二进制出来。 针对包的依赖实现package_id() self.info对象中包含requires对象，其中存储了所有直接和间接依赖的必要信息。例如self.info.requires[\"MyOtherLib\"]是一个RequirementInfo对象，它包含如下只读属性： full_name: 完整的依赖名，如“MyOtherLib” full_version: 完整的依赖版本，如“1.2” full_user: 依赖的包的完整user属性，如“my_user” full_channel: 依赖的包的channel属性,如“stable” full_package_id: 依赖的包的完整package ID, 如“c6d75a…” 下面的字段将会被用于package_id()的计算中： name: 默认就是full_name, 例如\"MyOtherLib\"； version: 默认是full_version中的主版本号。例如“1.2”中取“1.Y”，而“1.2.3”则取“1.Y.Z”（也就是忽略1后面的其它从版本号）； user: 默认为None，即不会影响package ID； channel: 默认为None，即不会影响package ID； package_id: 默认为None，即不会影响package ID； 依赖关系对package ID的影响，主要考虑一下两个因素： 版本结构对包的影响（例如采用semver还是客户自定义的版本定义） 二进制库的可重用性 (动态库还是静态库，动态库类型：.so, .dll, .dylib) 版本结构 Conan默认使用语义化版本。例如从2.0升级到2.1假定是API兼容，因此客户可以不用重新构建二进制。同样的从2.1.10升级到2.1.11被认为是增加patch，也不需要重新构建。而主版本号升级被认为是API不兼容升级，需要重新构建二进制。 当然可以通过定制package_id()来改变上述默认行为。 from conans import ConanFile, CMake, tools from conans.model.version import Version class PkgConan(ConanFile): name = \"Mylib\" version = \"1.0\" settings = \"os\", \"compiler\", \"build_type\", \"arch\" requires = \"MyOtherLib/2.0@lasote/stable\" def package_id(self): myotherlib = self.info.requires[\"MyOtherLib\"] # Any change in the MyOtherLib version will change current Package ID myotherlib.version = myotherlib.full_version # Changes in major and minor versions will change the Package ID but # only a MyOtherLib patch won't. E.g., from 1.2.3 to 1.2.89 won't change. myotherlib.version = myotherlib.full_version.minor() Conan提供了一些列的帮助函数，用来控制版本号以及user和channel是否影响到二进制和package ID，你可以选择使用： Modes / Variables name version user channel package_id RREV PREV semver_direct_mode() Yes Yes, only > 1.0.0 (e.g., 1.2.Z+b102) No No No No No semver_mode() Yes Yes , only > 1.0.0 (e.g., 1.2.Z+b102) No No No No No major_mode() Yes Yes(e.g., 1.2.Z+b102) No No No No No minor_mode() Yes Yes(e.g., 1.2.Z+b102) No No No No No patch_mode() Yes Yes(e.g., 1.2.3+b102) No No No No No base_mode() Yes Yes(e.g., 1.7+b102) No No No No No full_version_mode() Yes Yes(e.g., 1.2.3+b102) No No No No No full_recipe_mode() Yes Yes(e.g., 1.2.3+b102) Yes Yes No No No full_package_mode() Yes Yes(e.g., 1.2.3+b102) Yes Yes Yes No No unrelated_mode() No No No No No No No recipe_revision_mode() Yes Yes Yes Yes Yes Yes No package_revision_mode() Yes Yes Yes Yes Yes Yes Yes 上面这些mode函数，具体的含义可以参考官方文档。这些函数所代表的模式可以应用与所有的依赖包，也可以只对独立的依赖包使用： def package_id(self): # apply semver_mode for all the dependencies of the package self.info.requires.semver_mode() # use semver_mode just for MyOtherLib self.info.requires[\"MyOtherLib\"].semver_mode() 另外，Conan默认使用的semver_direct_mode，你也可以通过修改~/.conan/conan.conf文件进行修改。修改后的conan.conf文件可以通过conan config install命令进行分享和安装。 [general] default_package_id_mode=full_package_mode 上述默认值调用发生在包配置文件中的package_id()的执行前，因此你仍然可以修改package_id()函数执行特殊操作。例如为纯头文件包修改package_id(): def package_id(self): self.info.header_only() # clears requires, but also settings if existing # or if there are no settings/options, this would be equivalent self.info.requires.clear() # or self.info.requires.unrelated_mode() 包类型：动态、静态还是头文件包 让我们通过例子来看看主要的场景： MyLib/1.0是一个动态库，链接了一个静态库MyOtherLib/2.0的包。现在当MyOtherLib/2.1的新包发布了，我们想要用它，需要重新为MyLib/1.0构建新的二进制吗？ 答案是需要的！因为MyOtherLib库的二进制是“嵌入”在MyLib/1.0的动态库中的。 MyLib/1.0是一个动态库，依赖了动态库MyOtherLib/2.0的包。这时当MyOtherLib/2.1的新包发布了，我们想要用它，需要重新为MyLib/1.0构建新的二进制吗？ 答案是需要看情况！这依赖于公开的头文件有没有发生变化。如果头文件没有发生变化，则不用重新构建。如果头文件发生了变化，取决于修改有没有影响到MyLib/1.0的使用方式。向头文件中增加新方法不会影响MyLib/1.0，但是如果修改了某些编译MyLib/1.0需要内联的函数的实现，则MyLib/1.0肯定是要重新构建的。这种情况下，如下配置是合理的： def package_id(self): # Any change in the MyOtherLib version, user or channel # or Package ID will affect our package ID self.info.requires[\"MyOtherLib\"].full_package_mode() # Or any change in the MyOtherLib version, user or # channel will affect our package ID self.info.requires[\"MyOtherLib\"].full_recipe_mode() MyLib/1.0是一个只有头文件的库，和任何形态（静态库或动态库纯头文件的库）的MyOtherLib/2.0包链接，这时当MyOtherLib/2.1的新包发布了，需要重新执行MyLib/1.0的构建吗？ 答案是不需要！MyLib/1.0一般配置package ID不参考任何settings、options以及任何的依赖。 def package_id(self): self.info.requires.clear() MyLib/1.0是一个静态库，链接了只有头文件的MyOtherLib/2.0包。当MyOtherLib/2.1发布了，需要重修构建新的MyLib/1.0吗？如果MyOtherLib的头文件仅仅被用于MyLib的一些头文件中，而且没有间接传递到MyLib的实现文件中，那么可以不用重新编译。更一般的情况下，MyLib会间接包含到MyOtherLib的头文件，所以每次MyOtherLib更新都需要重新构建MyLib。如果我们可以确保MyOtherLib每次的channel变更不会引起MyLib的变化，那么可以如下配置： def package_id(self): self.info.requires[\"MyOtherLib\"].full_package() self.info.requires[\"MyOtherLib\"].channel = None # Channel doesn't change out package ID Inspecting Packages 可以使用conan get查看本地缓存中的包，或者是已经上传的包。 列出本地包里的文件： $ conan get zlib/1.2.11@ . Listing directory '.': conandata.yml conanfile.py conanmanifest.txt 打印二进制包的conaninfo.txt文件： $ conan get zlib/1.2.11@:2144f833c251030c3cfd61c4354ae0e38607a909 打印远端仓库中的包的conanfile.py文件： $ conan get zlib/1.2.11@ -r conan-center import os import stat from conans import ConanFile, tools, CMake, AutoToolsBuildEnvironment from conans.errors import ConanException class ZlibConan(ConanFile): name = \"zlib\" version = \"1.2.11\" url = \"https://github.com/conan-io/conan-center-index\" homepage = \"https://zlib.net\" #... 更多关于conan get的用法看这里。 打包方法 包配置文件里面有三个方法用来控制包的二进制兼容性以及实现不同的打包方法：package_id(), build_id()以及package_info()。这些函数可以让包的创建者为每个库选择合适的打包方法。 1 config (1 build) -> 1 package 一个典型的打包方式是一个配置对应一个包含工件的包。这种方式下，为debug模式下与构建的库将于release模式下预构建的库处于不同的包中。 因此，如果根据一个包配置构建出hello的库，那么将会有一个包含hello.lib的release版本的包，以及一个debug版本的包含hello.lib的包。 使用这种方式，package_info()方法允许你为用户设置不同的信息，让用户指导包中的库的名字、必须的条件编译以及编译参数。 class HelloConan(ConanFile): settings = \"os\", \"compiler\", \"build_type\", \"arch\" def package_info(self): self.cpp_info.libs = [\"mylib\"] 这里很关键的一步是记得要在settings中声明build_type，这意味着不同的build_type值将会产生不同的包。 包中声明的和构建相关的值都会被传递到为目标构建系统生成的文件中。例如为cmake生成的conanbuildinfo.cmake中会包含以下变量： set(CONAN_LIBS_MYPKG mylib) # ... set(CONAN_LIBS mylib ${CONAN_LIBS}) 这些变量被使用在conan_basic_setup()宏中，被设值到对应的cmake变量中。 如果用户想要在不同的配置中切换，需要如下命令： $ conan install -s build_type=Release ... # when need to debug $ conan install -s build_type=Debug ... 1 config (1 build) -> 1 package的方法有很多优点：它容易实现和维护；生成的包的大小是最小的，因此省磁盘以及传输快；不同的包解耦有助于定位问题。但是要注意不要将不同的包分发错误。 N configs -> 1 package 你可能希望将debug和release的发布物打包在一个包中，以便可以使用IDE，直接在IDE中切换debug/release版本而不用使用命令行切换包。这种类型的包中包含了不同配置的不同交付物，可以把release和debug版本的库放在一个包里面。 Github上有该类型的一个完整样例：https://github.com/conan-io/examples，具体在“features/multi_config”目录下。进入这个目录执行conan create . user/channel就可以创建对应的包。 创建一个同时包含debug/release的包并不复杂。 首先在包配置的settings中移除build_type属性。这样为debug和release将会构建同样的package ID的包。 class HelloConan(ConanFile): # build_type has been omitted. It is not an input setting. settings = \"os\", \"compiler\", \"arch\" generators = \"cmake\" # Remove runtime and use always default (MD/MDd) def configure(self): if self.settings.compiler == \"Visual Studio\": del self.settings.compiler.runtime def build(self): cmake_release = CMake(self, build_type=\"Debug\") cmake_release.configure() cmake_release.build() cmake_debug = CMake(self, build_type=\"Release\") cmake_debug.configure() cmake_debug.build() 上例中的configure()函数中对compiler.runtime subsetting的特殊操作是针对Visual Studio的，删除掉Visual Studio中的差异化运行时（MD`MDd`）。 本例中，按照CMake的语法，二进制需要有不同的后缀，所以我们需要在package_info函数中将其标记给用户。 def package_info(self): self.cpp_info.release.libs = [\"mylibrary\"] self.cpp_info.debug.libs = [\"mylibrary_d\"] 这些信息将会传递到CMake的变量中： set(CONAN_LIBS_MYPKG_DEBUG mylibrary_d) set(CONAN_LIBS_MYPKG_RELEASE mylibrary) # ... set(CONAN_LIBS_DEBUG mylibrary_d ${CONAN_LIBS_DEBUG}) set(CONAN_LIBS_RELEASE mylibrary ${CONAN_LIBS_RELEASE}) 这些变量会被CMake的conan_basic_setup()宏中被正确的赋值。 虽然包中同时有debug和release的构建产物，但是任然有很多共享的配置。例如头文件的include目录，这将会产生共享的CMake变量供消费者使用。 N configs (1 build) -> N packages Conan支持通过一个构建脚本为不同的配置构建不同的二进制。例如debug/release，或者不同的架构(32/64bit)，或者库类型(shared/static)。如果每个变化都执行一次构建，那么将会浪费很多构建时间和资源。可以优化构建逻辑，使用一次构建产生不同的包。 这可以通过在包的配置文件中定义一个build_id()函数来搞定。 settings = \"os\", \"compiler\", \"arch\", \"build_type\" def build_id(self): self.info_build.settings.build_type = \"Any\" def package(self): if self.settings.build_type == \"Debug\": #package debug artifacts else: # package release 在build_id()函数中使用了self.info.build对象来改变构建的哈希ID。通过设置build_type=\"Any\"，我们强制无论是debug还是release版本的构建，都将产生同一个build的哈希ID。 影响构建目录多少的不止有这一个属性，还有其它配置也会影响到构建目录的个数（体系架构Architecture，编译器版本 compiler version等）。但是通过自定义build_id()函数，合并这些选项可以减少构建目录数，节省构建时间。更多信息可以参考build_id()的详细介绍。 包创建工具 使用Python脚本（或者shell命令以及bash脚本），可以使我们自动化的为不同的配置执行打包和测试流程。例如你可以将如下脚本放在包的根目录下，将其命名为build.py。 import os, sys import platform def system(command): retcode = os.system(command) if retcode != 0: raise Exception(\"Error while executing:\\n\\t %s\" % command) if __name__ == \"__main__\": params = \" \".join(sys.argv[1:]) if platform.system() == \"Windows\": system('conan create . demo/testing -s compiler=\"Visual Studio\" -s compiler.version=14 %s' % params) system('conan create . demo/testing -s compiler=\"Visual Studio\" -s compiler.version=12 %s' % params) system('conan create . demo/testing -s compiler=\"gcc\" -s compiler.version=4.8 %s' % params) else: pass 运行这个脚本：python build.py，就会自动根据当前平台创建不同配置的包。 Conan官方开发了一个FOSS的工具Conan Package Tools，用于帮助我们从一个包配置文件构建多个不同的二进制包。它提供了简单的方式来定义配置并调用conan test。另外它提供了和CI（Travis CI, Appveyor and Bamboo,）集成的工具，以及基于云环境自动创建、测试和上传二进制包。 这个工具可以让我们简单的通过git push在云上创建成千上百的二进制包。具体如下： 轻易的根据不同的配置产生不同的conan包； 启动的在Travis/Appveyor服务器通过CI Job执行分布式的构建； 基于Docker容器，自动的在Travis-CI上为Linux上的gcc和clang的多个版本构建包； 自动的在Travis-CI上通过app-clang为OSX系统创建包； 支持Visual Studio，根据检测到的环境自动进行命令行的环境配置； 可以通过pip安装它：$ pip install conan_package_tools。更多介绍请阅读github中的README.md。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"06-uploading-packages.html":{"url":"06-uploading-packages.html","title":"上传包","keywords":"","body":"上传包 这一节一起来看看如何将包上传到指定的远端包仓库。 远端仓库 在前面我们创建的包都是存在本地缓存中，一般在~/.conan/data。现在我们想将它们上传到Conan Server上，以便可以在别的机器和项目上使用它们。 Conan的包可以被上传到提前配置好名字和URL的不同远端仓上。这些远端仓是用来存储包的二进制的服务器。 有好几种的远端仓。对于私有开发有以下选择： Artifactory Community Edition for C/C++ ： 它是一个完全免费的Conan服务端仓库，推荐公司或者团队使用它作为自己的私有仓库。它有一个web UI，先进的鉴权和权限管理，较好的性能和扩展性，对应的REST API，以及能够作为服务器存储交付件（如tar包，Zip文件等）。 Artifactory Pro：Artifactory Pro可以管理所有主要包格式的二进制仓库。它是推荐给企业的更专业的包管理仓库。具体可以在Artifactory documentation了解更多。 Conan server：简单免费开源的、MIT license的服务端，和conan客户端一起发布。 对于包的分发，可以使用Bintray。 Bintray是一个云平台，可以让你对发布、存储、分发软件具有完全的控制。您可以在Bintray中创建二进制存储库来共享Conan包，甚至创建一个组织。它对于开源软件包是免费的，并免费提供分发到C和C++社区的推荐服务器。 Conan-center Conan-center(https://bintray.com/conan/conan-center)是主要的官方仓库，提供服务给开源的Conan包。它是本地的默认远端仓配置，如下也可以手动将其添加到配置：`conan remote add conan-center https://conan.bintray.com`。 在Conan-center中当前有两种不同类型的包： 完全引用的包： 例如\"pkg/version@user/channel\"。这种包是用户在自己的Bintray仓库中创建的，然后包含在这里。现在不推荐继续使用这种包的分发方式了。 没有user/channel的包：能够直接以pkg/version方式使用的包，这种包是通过Conan的C3I(Conan-Center Continuous Integration)服务自动根据conan-center-index从github上创建出来的。 Bintray的社区仓库 有几个很流行的社区仓库，它们也提供conan用户下载自己感兴趣的包。这些仓库并不属于conan团队。 Bincrafters ： https://bintray.com/bincrafters/public-conan Bincrafters团队构建了许多二进制软件包给OSS社区。这个仓库包含了大量的Conan包。 如下命令可以将这个仓库添加到Conan中： $ conan remote add bincrafters https://api.bintray.com/conan/bincrafters/public-conan Conan Community: https://bintray.com/conan-community/conan 这是conan开发者组织的，用于将包发布于Conan Center前测试和孵化包的。这个仓库包含一些成熟过程中的包，可能还不能工作或者特性不齐全。 如下命令将这个仓库添加到Conan中： $ conan remote add conan-community https://api.bintray.com/conan/conan-community/conan 将包上传到远端库 首先可以列出目前配置的远端库： $ conan remote list 如下可以将任意的远端库添加到你的机器上： $ conan remote add my_local_server http://localhost:9300 可以搜索远端库： $ conan search -r=my_local_server 现在，上传包配置以及所有生成的二进制包到远端。本例中，我们使用my_local_server表示指定的远端库，你可以换成其它的： $ conan upload Hello/0.1@demo/testing --all -r=my_local_server 上述命令可能会弹出要求输入用户名和密码。默认的Conan sever有一个demo/demo账户供我们测试。 --all选项指示上传包配置以及所有的二进制。忽略--all选项将会只上传包的配置文件。可以控制上传的二进制，--package允许显示指定上传的包的package ID；--query可以指定query参数，例如arch=armv8 and os=Linux，则会上传所有匹配的二进制包。在shell中如下调用：conan upload -q 'arch=x86_64 and os=Linux' ...。 这时就可以在自己机器或者局域网中其它机器上查找到这个包了： $ conan search Hello/0.1@demo/testing -r=my_local_server 如果上传包失败，可以再次尝试。Conan会记录住当前上传进度以及只上传缺失的文件。 现在我们可以检查是否可以下载并使用上传的包。我们首先把本地的包删掉，否则就不会从远端下载。 $ conan remove \"Hello*\" $ conan search 我们可以复用之前Hello包里的测试工程，而指定不将Hello包构建及导出。 $ conan create . demo/testing --not-export --build=never 这时我们会看到conan从本地server上下载对应的二进制包。 使用Bintray 在Bintray上，你可以创建和管理许多的个人免费的Conan仓库。对于一个OSS账户，所有你上传的包都是公开的，其他人可以简单的将你的仓库添加到他们的Conan远端仓，然后使用你发布的包。 为了能够让团队在开源工程上协作，你可以在Bintray上创建组织，然后加入成员。这样你们就可以共同创建和编辑你们组织仓库内的包了。 上传包至Bintray 在Bintray上创建一个开源账户。打开https://bintray.com/signup/oss，提交表单创建账户; 创建conan仓库。在你的账户下创建一个conan仓库，如果你的仓库需要和别人协作，则需要先创建一个组织（organization）; 将创建的conan仓库添加到本地配置中：conan remote add ; 库的URL地址在页面中点击“set me up”按钮可以看到； 获得你的API key：你的API key是Bintray认证conan客户端的密码，不是你登录Bintray的密码。在Bintray上点击Edit Your Profile，然后在你的账户配置中获取你的API key； 设置你的证书，增加Conan用户，使用API key，你的远端库和Bintray的用户名：conan user -p -r ; 设置成功后，你的Conan客户端将会按照以下顺序从远端仓解析以及下载安装包： conan-center 你自己的仓库 如果想要将自己的仓库放在前面，可以在添加仓库时使用--insert命令行参数： $ conan remote add --insert 0 $ conan remote list : [Verify SSL: True] conan-center: https://conan.bintray.com [Verify SSL: True] 贡献包到Conan-center 对Conan-center贡献包，可以直接通过向https://github.com/conan-io/conan-center-index提交pull request。C3I（Conan-center Continuous Integration）服务将会自动从合并后的pull request构建二进制包，并上传能到Conan-center。具体的操作见github上的https://github.com/conan-io/conan-center-index/wiki。 Artifactory Community Edition C/C++的Artifactory Community Edition(CE)社区版本，推荐给想要做包的私有存储的团队或公司使用。社区版是完全免费的，它包含Web UI、鉴权与权限管理，很好的心梗与扩展性、REST API、一个命令行工具、以及能够存储任何源码和二进制的仓库。 本节简单介绍下的Artifactory CE，更详细的推荐查看Artifactory的文档。 运行 Artifactory CE 有好几种下载和运行Artifactory CE的方法。最简单的是下载zip包，解压后安装。压缩包里面还包含了一个Docker Image，也可以从docker启动。 一旦运行起来，访问“http://localhost:8081”，使用默认用户名密码：`admin:password`登录。 创建和使用Conan仓库 从页面导航到Admin -> Repositories -> Local，然后点击\"New\"，再出现的对话框中选Conan，输入Repository Key，为创建的仓库起个名字。你可以根据需要按照不同的工作流、团队或者工程创建多个仓库。 然后就需要配置客户端了。在仓库页面点击\"Set Me Up\"拷贝正确的远端库的地址，然后配置Conan客户端： $ conan remote add artifactory http://localhost:8081/artifactory/api/conan/conan-local 现在你可以往仓库中上传、下载或者查询包了。 $ conan upload \"*\" --all -r=artifactory $ conan search \"*\" -r=artifactory 从其它服务端迁移包 如果你有了自己的包服务仓库，可能需要从别的仓库（例如Conan-center）把包迁移过来。包的迁移并不复杂，只用使用Conan客户端将包下载下来，然后重新上传到新的服务器上即可。 有个Python脚本会更高效一些。下例中我们分别用'local'和'artifactory'表示两个仓库： import os import subprocess def run(cmd): ret = os.system(cmd) if ret != 0: raise Exception(\"Command failed: %s\" % cmd) # Assuming local = conan_server and artifactory remotes output = subprocess.check_output(\"conan search -r=local --raw\") packages = output.splitlines() for package in packages: print(\"Downloading %s\" % package) run(\"conan download %s -r=local\" % package) run(\"conan upload \\\"*\\\" --all --confirm -r=artifactory\") 使用conan_server conan_server是免费开源版本的Conan远端库实现。它是一个简单的应用程序，和Conan的客户端一起绑定安装。conan_server仅建议用来测试，或者对小团队使用。大多数场合下更推荐使用免费的Artifactory Community Edition搭建私有的包仓库。 如果已经下载安装过Conan本地程序了的话，那么运行conan_server仅需要一行命令：conan_server。 从源码运行 (linux) 从源码运行conan_server，可以用WSGI（例如gunicorn）启动它，这样会更加的稳定。 $ git clone https://github.com/conan-io/conan.git $ cd conan $ git checkout master $ pip install -r conans/requirements.txt $ pip install -r conans/requirements_server.txt $ pip install gunicorn 下载好源码后，如下将其启动在9300端口： $ gunicorn -b 0.0.0.0:9300 -w 4 -t 300 conans.server.server_launcher:app 服务配置 可以在~/.conan_server/server.conf中对服务进行配置，配置好后重新启动服务load新的配置。 [server] jwt_secret: MnpuzsExftskYGOMgaTYDKfw jwt_expire_minutes: 120 ssl_enabled: False port: 9300 public_port: host_name: localhost store_adapter: disk authorize_timeout: 1800 # Just for disk storage adapter disk_storage_path: ~/.conan_server/data disk_authorize_timeout: 1800 updown_secret: NyiSWNWnwumTVpGpoANuyyhR [write_permissions] # \"opencv/2.3.4@lasote/testing\": default_user,default_user2 [read_permissions] # opencv/1.2.3@lasote/testing: default_user default_user2 # By default all users can read all blocks */*@*/*: * [users] demo: demo 关于配置的含义，以及如何将conan_server配置在Nginx中，请参考具体的配置文档。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"07-developing-packages.html":{"url":"07-developing-packages.html","title":"开发包","keywords":"","body":"开发包 包开发流程 在先前的例子中，我们使用conan create命令创建了包，每次运行这条命令，Conan执行如下步骤： 将源码拷贝到一个新创建的干净的build目录下； 从源码构建完整的库； 当构建成功后，将库打包； 构建test_package样例并运行测试； 有的时候，我们构建的库很大，每次重复上述过程有些消耗和浪费。本节描述详细的包开发流程，深入的理解可以对该过程做优化。 conan source 我们可以从conan source命令开始。这条命令会按照你的包配置下载源码文件，将其放到临时的子目录(source-folder参数指定)中。 $ cd example_conan_flow $ conan source . --source-folder=tmp/source PROJECT: Configuring sources in C:\\Users\\conan\\example_conan_flow\\tmp\\source Cloning into 'hello'... conan install conan install用于激活所有和依赖相关的操作。 参数install-folder指定安装文件的生成目录。 $ conan install . --install-folder=tmp/build [--profile XXXX] PROJECT: Installing C:\\Users\\conan\\example_conan_flow\\conanfile.py Requirements Packages ... 上面我们通过conan install在“tmp/build”子目录下生成了conaninfo.txt以及conanbuildinfo.cmake文件。 conan build build方法需要源码的路径以及install目录（获得依赖以及包配置文件），然后它就可以执行构建了。 $ conan build . --source-folder=tmp/source --build-folder=tmp/build Project: Running build() ... Build succeeded. 0 Warning(s) 0 Error(s) Time Elapsed 00:00:03.34 这里如果我们忽略--install-folder=tmp/build，它将默认取--build-folder参数的值。 如果你只需要修改代码重新构建包，其实只用像这个例子这样调用conan build就可以了。 conan package conan package将会调用包配置文件中的package()函数。它需要所有的其它目录信息（源码中的头文件、install目录下的包依赖信息、构建的结果），以便能够执行打包。 $ conan package . --source-folder=tmp/source --build-folder=tmp/build --package-folder=tmp/package PROJECT: Generating the package PROJECT: Package folder C:\\Users\\conan\\example_conan_flow\\tmp\\package PROJECT: Calling package() PROJECT package(): Copied 1 '.h' files: hello.h PROJECT package(): Copied 2 '.lib' files: greet.lib, hello.lib PROJECT: Package 'package' created conan export-pkg 当你检查你的包没有问题，这时你可以使用conan export-pkg将其导出到你的本地conan包缓存。这个命令需要的参数和package()一样，它会完整的重新执行一遍打包过程，以确认包的产生是可以重复的。 $ conan export-pkg . user/channel --source-folder=tmp/source --build-folder=tmp/build --profile=myprofile Packaging to 6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 Hello/1.1@user/channel: Generating the package Hello/1.1@user/channel: Package folder C:\\Users\\conan\\.conan\\data\\Hello\\1.1\\user\\channel\\package\\6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 Hello/1.1@user/channel: Calling package() Hello/1.1@user/channel package(): Copied 2 '.lib' files: greet.lib, hello.lib Hello/1.1@user/channel package(): Copied 2 '.lib' files: greet.lib, hello.lib Hello/1.1@user/channel: Package '6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7' created 使用source-folder和build-folder将会调用package()函数从这些目录里抽取需要的文件在本地缓存里面创建包。这里不需要提前执行conan package。但是你在开发的时候可能需要conan package命令做中间的调试； 如果在上例中使用package-folder参数，那么将不会调用package()函数，它将假定包已经通过之前的conan package创建好了，并直接从提供的目录中进行拷贝生成包。 conan test 最后一步就是测试包。 $ conan test test_package Hello/1.1@user/channel Hello/1.1@user/channel (test package): Installing C:\\Users\\conan\\repos\\example_conan_flow\\test_package\\conanfile.py Requirements Hello/1.1@user/channel from local Packages Hello/1.1@user/channel:6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 Hello/1.1@user/channel: Already installed! Hello/1.1@user/channel (test package): Generator cmake created conanbuildinfo.cmake Hello/1.1@user/channel (test package): Generator txt created conanbuildinfo.txt Hello/1.1@user/channel (test package): Generated conaninfo.txt Hello/1.1@user/channel (test package): Running build() 最后完整的过程如下： $ git clone git@github.com:memsharded/example_conan_flow.git $ cd example_conan_flow $ conan source . $ conan install . -pr=default $ conan build . $ conan package . # So far, this is local. Now put the local binaries in cache $ conan export-pkg . Hello/1.1@user/testing -pr=default # And test it, to check it is working in the local cache $ conan test test_package Hello/1.1@user/testing ... Hello/1.1@user/testing (test package): Running test() Hello World! conan create 现在我们知道了包配置的详细执行步骤。conan create是对上面命令的合并，除了conan test。 $ conan create . user/channel 即使使用这个命令，包创建者仍然可以在本地包缓存中迭代执行（当调试的时候），可以通过--keep-source和--keep-build参数。 如果在过程中看到source()方法执行成功了，但是包的构建执行失败了，则再次执行可以使用--keep-source。 $ conan create . user/channel --keep-source Hello/1.1@user/channel: A new conanfile.py version was exported Hello/1.1@user/channel: Folder: C:\\Users\\conan\\.conan\\data\\Hello\\1.1\\user\\channel\\export Hello/1.1@user/channel (test package): Installing C:\\Users\\conan\\repos\\example_conan_flow\\test_package\\conanfile.py Requirements Hello/1.1@user/channel from local Packages Hello/1.1@user/channel:6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 Hello/1.1@user/channel: WARN: Forced build from source Hello/1.1@user/channel: Building your package in C:\\Users\\conan\\.conan\\data\\Hello\\1.1\\user\\channel\\build\\6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 Hello/1.1@user/channel: Configuring sources in C:\\Users\\conan\\.conan\\data\\Hello\\1.1\\user\\channel\\source Cloning into 'hello'... remote: Counting objects: 17, done. remote: Total 17 (delta 0), reused 0 (delta 0), pack-reused 17 Unpacking objects: 100% (17/17), done. Switched to a new branch 'static_shared' Branch 'static_shared' set up to track remote branch 'static_shared' from 'origin'. Hello/1.1@user/channel: Copying sources to build folder Hello/1.1@user/channel: Generator cmake created conanbuildinfo.cmake Hello/1.1@user/channel: Calling build() 如果你看到构建成功执行了，则可以使用--keep-build来跳过build()函数的执行。 $ conan create . user/channel --keep-build` 可编辑模式(editable mode)的包 注意：这是个实验特性，未来发布的版本可能会发生不兼容的修改。 当在有多个内在功能互相关联的大型项目中工作时，建议不要将工程组织成一个大的单体项目。推荐将项目分解成多个库，每个库专门完成一组内聚的任务，甚至分配给专门的开发团队维护。这种方式有助于隔离和重用代码，缩短编译时间，并减少include了错误头文件的可能性。 然而，在某些情况下，同时工作在多个库上，能够及时看到一个修改后对其它的影响，这点也是很有用的。我们前面介绍的工作流：conan source,conan install, conan build, conan package, 以及conan export-pkg，会将包构建后发布到本地缓存，为使用者做好准备。 但是，使用可编辑模式包，你能够告诉Conan从本地工作目录下查找包的头文件以及构建产物，而无需将包导出。 我们用一个例子来看看这个特性。假设开发者创建了一个CoolApp的应用，紧密依赖了一个cpp/version@user/dev的库。包cpp/version@user/dev已经可以工作了，开发者在本地目录下开发了代码，他们随时可以构建并执行conan create . cool/version@user/dev来创建这个包。同时，CoolApp里面有一个conanfile.txt(或者conanfile.py)，描述了它依赖于cpp/version@user/dev。当构建这个程序的时候，它将从Conan的本地缓存中查找依赖的cool包。 将包设置为可编辑模式 避免每次修改cpp/version@user/dev都需要在Conan缓存中创建包，我们可以将包设置为可修改模式：通过创建一个从Conan缓存到本地工作目录的引用连接。 $ conan editable add cool/version@user/dev # you could do \"cd && conan editable add . cool/version@user/dev\" 执行上述命令后，本地的包或者项目每次使用cpp/version@user/dev，都将会重镜像到目录下，不会再从Conan缓存中去获取。 Conan的包配置文件通过package_info()函数定义了包的布局（layout）。如果不做修改，默认的布局如下述代码所示： def package_info(self): # default behavior, doesn't need to be explicitly defined in recipes self.cpp_info.includedirs = [\"include\"] self.cpp_info.libdirs = [\"lib\"] self.cpp_info.bindirs = [\"bin\"] self.cpp_info.resdirs = [\"res\"] 这意味着conan将会使用路径path/to/local/dev/libcool/include查找cool的头文件，通过path/to/local/dev/libcool/lib查找对应的库文件。 但是，实际情况是，大部分包在开发过程中经常做增量构建，构建目录的布局和包最终发布的布局不会完全一样。当然每次增量构建后可以执行conan package进行打包，使得布局满足包布局要求，但是这样不够优雅。Conan提供了几种为可编辑模式下的包自定义包布局的方式。 可编辑模式的包布局 可编辑模式的包的布局有几种不同的自定义方式： 通过包配置文件定义 通过包配置文件中的package_info()函数进行定义： from conans import ConanFile class Pkg(ConanFile): settings = \"build_type\" def package_info(self): if not self.in_local_cache: d = \"include_%s\" % self.settings.build_type self.cpp_info.includedirs = [d.lower()] 上述代码通过构建类型来配置头文件的目录布局。如果build_type=Debug，则include目录是path/to/local/dev/libcool/include_debug，否则是path/to/local/dev/libcool/include_release。同样，其它的目录（libdirs，bindirs等）都可以如此自定义。 通过布局文件（layout files）配置 除了通过包配置文件自定义布局，还可以使用独立的布局文件。这对于有很多的库共享相同的布局的时候很有用。 布局文件是一些ini文件，但是Conan做了扩展，可以使用Jinja2模板引擎。在配置文件里面使用settings、options以及当前的reference对象，可以为布局配置文件增加逻辑： [includedirs] src/core/include src/cmp_a/include [libdirs] build/{{settings.build_type}}/{{settings.arch}} [bindirs] {% if options.shared %} build/{{settings.build_type}}/shared {% else %} build/{{settings.build_type}}/static {% endif %} [resdirs] {% for item in [\"cmp1\", \"cmp2\", \"cmp3\"] %} src/{{ item }}/resouces/{% if item != \"cmp3\" %}{{ settings.arch }}{% endif %} {% endfor %} Jinja的语法可以查看它的官方文档。 布局描述文件也可以对指定的包做配置，下面例子中设置cool包的include目录为src/core/include，而其它的则是src/include。 [includedirs] src/include [cool/version@user/dev:includedirs] src/core/include 可编辑模式下的包的客赔目录有includedirs, libdirs, bindirs, resdirs, 以及builddirs。所有这些都在包描述文件的cpp_info的字典字段中，而该字典中其它值都是不能修改的，例如cflags、defines等。 默认所有的路径都是相对于conanfile.py的相对路径，也可以用绝对路径。 为包指定布局文件使用conan editable add命令，例如： $ conan editable add . cool/version@user/dev --layout=win_layout win_layout文件首先会在当前文件夹下查找，所以可将将其和源码放到一起，一起发布和被共享使用。如果在当前目录下没有找到，则会在本地缓存~/.conan/layouts目录下查找。可以定义布局文件共享给团队，然后通过conan config install进行安装。 如果conan editable add命令没有参数，将会默认使用~/.conan/layouts/default文件中描述的布局。 对于布局，Conan会按照以下优先级选择： 首先会执行包配置文件中的package_info()函数。这会定义各种标记参数（例如cflags）、definitions（例如-D的宏参数）以及布局目录: includedirs, libdirs等等； 如果布局文件存在，或者显示的应用了默认的.conan/layouts/default文件，Conan将会查找对应的匹配布局文件； 如果找到匹配的布局文件，则会使用布局文件中的定义替换(includedirs, libdirs, resdirs, builddirs, bindirs)； 布局文件的匹配，按照从特殊到一般的顺序 （布局文件可以为指定的包指定特殊的目录布局）； 如果没有匹配的，则仍旧使用原来定义在package_info()中的目录结构； 如果在conan editable add之后，手动增加了.conan/layouts/default文件，它将不会被使用； 使用可编辑模式的包 一旦对一个包建立了可编辑模式的引用，它就会对整个系统生效：所有本机（使用相同的conan缓存）的对其有依赖的工程或者包，都会重镜像到可编辑模式包的真实工作目录。 一个可编辑模式的包，对它的用户来说是透明的。使用可编辑模式的包的工作流如下： 通过git/svn clone ... && cd folder获得cool/version@user/dev的源码； 将包设置为可编辑模式：conan editable add . cool/version@user/dev --layout=mylayout; 现在可以正常编码和构建。注意你本地工作目录下的'cool'包的目录结构布局要和前面命令中的mylayout文件制定的一样； 对于消费cool的工程CoolApp，和以前一样，使用conan install并执行构建； 回到cool/version@user/dev的源码目录，修改代码并构建，这里不需要执行任何Conan命令以及打包； 回到CoolApp目录，重新构建它，测试cool的修改对其的影响； 可以看到，可以同时开发cool和CoolApp，不用反复打包发包。 注意：当一个包处于可编辑模式，大多数的工作也不会工作。可编辑模式的包不能使用conan upload, conan export或者conan create命令。 取消包的可编辑模式 取消包的可编辑模式，使用如下命令： $ conan editable remove cool/version@user/dev 当执行上述命令后，所有对包的消费将会重新需要从本地包缓存中获取。 工作区（Workspaces） 注意：这个特性在实验中，当前的预览特性是为了收集反馈以便于改进。未来的版本中，文件格式、命令、以及工作流都有可能发生变化。 有的时候，需要同时开发处理多个包，理论上，每个包都需要是一个独立的工作单元(work unit)。但有的时候，确实存在一些修改需要同时跨越多个包，按照之前的本地开发流程，需要使用export-pkg将包发布到本地缓存，以便其它正在开发的包可以消费它。 Conan工作区（workspace）允许多个包存在于用户目录下，互相之间直接依赖，而不用将它们导出到本地缓存。更进一步，允许包含多个包的大工程执行增量构建。 我们用一个例子来介绍这个特性： $ git clone https://github.com/conan-io/examples.git $ cd features/workspace/cmake 可以看到这个目录下包含两个文件conanws_gcc.yml以及conanws_vs.yml。conanws_gcc.yml示例了一个基于Makefile的单配置构建环境（Single configuration build environments）；而conanws_vs.yml示例了一个基于MSBuild的多配置构建环境（MSBuild, multi-configuration build environment)。 Conan工作区定义 工作区使用yaml文件来定义，用户可以随意为配置文件命名。文件结构如下： editables: say/0.1@user/testing: path: say hello/0.1@user/testing: path: hello chat/0.1@user/testing: path: chat layout: layout_gcc workspace_generator: cmake root: chat/0.1@user/testing editables段定义了多个包和其相对路径。每一个等价于下面的conan editable add命令，但是你不用执行这些命令，工作区稍后会自动完整配置。 $ conan editable add say say/0.1@user/testing --layout=layout_gcc $ conan editable add hello hello/0.1@user/testing --layout=layout_gcc $ conan editable add chat chat/0.1@user/testing --layout=layout_gcc 工作区中的包的可编辑状态仅对工作区内有效，不会影响到其它工程和包。其它不在工作区内的工程和包仍需要通过本地包缓存消费say、hello以及chat包。 工作区配置文件中的layout: layout_gcc会影响到对应的所有的包，也可以单独为某个包定义不同的目录布局，例如： editables: say/0.1@user/testing: path: say layout: custom_say_layout 关于可编辑模式的包以及其布局文件的介绍在上一节。 workspace_generator定义了将会为顶级工程产生的文件。当前配置为cmake，将会产生如下的conanworkspace.cmake文件： set(PACKAGE_say_SRC \"/examples/workspace/cmake/say/src\") set(PACKAGE_say_BUILD \"/examples/workspace/cmake/say/build/Debug\") set(PACKAGE_hello_SRC \"/examples/workspace/cmake/hello/src\") set(PACKAGE_hello_BUILD \"/examples/workspace/cmake/hello/build/Debug\") set(PACKAGE_chat_SRC \"/examples/workspace/cmake/chat/src\") set(PACKAGE_chat_BUILD \"/examples/workspace/cmake/chat/build/Debug\") macro(conan_workspace_subdirectories) add_subdirectory(${PACKAGE_say_SRC} ${PACKAGE_say_BUILD}) add_subdirectory(${PACKAGE_hello_SRC} ${PACKAGE_hello_BUILD}) add_subdirectory(${PACKAGE_chat_SRC} ${PACKAGE_chat_BUILD}) endmacro() 这个文件可以被包含在你自定义的CMakeLists.txt中。你可以看到示例工程中的CMakeLists.txt是如下使用的： cmake_minimum_required(VERSION 3.0) project(WorkspaceProject) include(${CMAKE_BINARY_DIR}/conanworkspace.cmake) conan_workspace_subdirectories() root: chat/0.1@user/testing定义了工作区的根工程，一般会是些可执行程序。你可以提供多个，用逗号分开。所有的根工程的依赖不能出现同一个库的不同版本。 editables: say/0.1@user/testing: path: say hello/0.1@user/testing: path: hello chat/0.1@user/testing: path: chat root: chat/0.1@user/testing, say/0.1@user/testing # or root: [\"HelloA/0.1@lasote/stable\", \"HelloB/0.1@lasote/stable\"] # or root: - HelloA/0.1@lasote/stable - HelloB/0.1@lasote/stable 单配置构建环境（Single configuration build environments） 对于一些构建系统（如Make），需要开发者在不同的build目录下管理不同的配置，然后在目录间切换以改变配置。conan_gcc.yml文件定义了一个Conan工作区，工作在基于MinGW/Unix Makefiles的gcc环境的CMake工程上。 如下使用并安装工作区： $ mkdir build_release && cd build_release $ conan workspace install ../conanws_gcc.yml --profile=my_profile 这里我们假定你有一个my_profile的profile文件，定义了linux gcc的相关构建目标配置（MAC下使用apple-clang也是可以执行这个示例的）。上述命令的输出如下： [settings] ... build_type=Release compiler=gcc compiler.libcxx=libstdc++ compiler.version=4.9 ... Requirements chat/0.1@user/testing from user folder - Editable hello/0.1@user/testing from user folder - Editable say/0.1@user/testing from user folder - Editable Packages chat/0.1@user/testing:df2c4f4725219597d44b7eab2ea5c8680abd57f9 - Editable hello/0.1@user/testing:b0e473ad8697d6069797b921517d628bba8b5901 - Editable say/0.1@user/testing:80faec7955dcba29246085ff8d64a765db3b414f - Editable say/0.1@user/testing: Generator cmake created conanbuildinfo.cmake ... hello/0.1@user/testing: Generator cmake created conanbuildinfo.cmake ... chat/0.1@user/testing: Generator cmake created conanbuildinfo.cmake 可以看到每个包下都产生了一个conanbuildinfo.cmake文件，目录结构定义在layout_gcc文件中： # This helps to define the location of CMakeLists.txt within package [source_folder] src # This defines where the conanbuildinfo.cmake will be written to [build_folder] build/{{settings.build_type}} 我们可以如下构建以及运行这个工程了： $ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release $ cmake --build . # or just $ make $ ../chat/build/Release/app Release: Hello World! Release: Hello World! Release: Hello World! 现在，到某一个包下面修改代码并执行构建，可以看看它可以执行更快的增量构建。另外，可以看到，包并没有安装到本地的conan缓存中，调用conan search say会返回查找失败。 注意，本例中每个包的conanfile.py和普通的包配置文件并没有什么差异，但是CMakeLists.txt有些不同：conan_basic_setup(NO_OUTPUT_DIRS）。这时因为默认的conan_basic_setup()会为工件(例如bin、lib等)定义输出目录，这些目录和本地工程期望的布局可能不同。你需要检查以确定你的构建脚本和包配置与工程期望的目录布局（定义在layout文件中的）是匹配的。 下面是为上例构建具有独立目录的debug模式： $ cd .. && mkdir build_debug && cd build_debug $ conan workspace install ../conanws_gcc.yml --profile=my_gcc_profile -s build_type=Debug $ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Debug $ cmake --build . # or just $ make $ ../chat/build/Debug/app Debug: Bye World! Debug: Bye World! Debug: Bye World! 多配置构建环境（Multi configuration build environments） 一些构建系统，如Visual Studio（MSBuild），使用多配置环境（multi-configuration）。这意味着工程被配置一次，然后你可以通过IDE在多个配置间（Debug/Release）切换。 上面的例子中Conan为每个构建目录（Debug/Release）产生一个独立的conanbuildinfo.cmake。对于Visual Studio，我们希望能欧在Debug和Release之间切换，我们重新在一个干净的构建目录上执行conan workspace install。 Conan有一个cmake_multi的生成器，允许直接通过IDE在Debug和Release之间切换。这个示例的工作区配置如下： editables: say/0.1@user/testing: path: say hello/0.1@user/testing: path: hello chat/0.1@user/testing: path: chat layout: layout_vs generators: cmake_multi workspace_generator: cmake root: chat/0.1@user/testing 注意上面generators: cmake_multi这句，定义了使用cmake_multi作为CMake生成器。因此，Conan将不会生成conanbuildinfo.cmake，而是生成conanbuildinfo_multi.cmake文件。可以看到“hello/src/CMakeLists.txt”文件中，会包含对应的cmake文件。 project(Hello) if(EXISTS ${CMAKE_CURRENT_BINARY_DIR}/conanbuildinfo_multi.cmake) include(${CMAKE_CURRENT_BINARY_DIR}/conanbuildinfo_multi.cmake) else() include(${CMAKE_CURRENT_BINARY_DIR}/conanbuildinfo.cmake) endif() conan_basic_setup(NO_OUTPUT_DIRS) add_library(hello hello.cpp) conan_target_link_libraries(hello) 上面文件最后的conan_target_link_libraries(hello)是一个帮助函数，可以让目标链接到正确的Debug或者Release库上。 根据需要安装对应的Debug或者Release配置。下面的配置将会产生一个Visual Studio的solution，你可以打开它选择执行程序。你可以同时为工程生成Release版本，然后在Visual Studio中进行Debug和Release的切换。 $ mkdir build && cd build $ conan workspace install ../conanws_vs.yml $ conan workspace install ../conanws_vs.yml -s build_type=Debug $ cmake .. -G \"Visual Studio 15 Win64\" 如果我们打开工程的build目录，可以看到多个版本的cmake文件都会在同一个build目录下，而不会有各自独立的目录。可以看看layout_vs文件，构建目录布局是[build_folder]而不是[build/{settings.build_type}]: [build_folder] build 源码之外构建 前面的例子都是使用可编辑模式的包的源码里面的build目录，也可以使用源码之外的build目录布局，依靠相对路径和reference参数。下面的布局定义了如何使用源码外的build目录存放所有包的构建结果： [build_folder] ../build/{{reference.name}}/{{settings.build_type}} [includedirs] src [libdirs] ../build/{{reference.name}}/{{settings.build_type}}/lib 补充 本节讲的包的开发方式最后并非真正的发布包（你仍然可以尝试使用conan export-pkg），推荐使用conan create创建并发布完整的包（最好是在持续集成服务器上）。 目前，工作区仅支持CMake的生成器，Visual Studio的目前在考虑中，尚不完全支持。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"08-package-apps-and-devtools.html":{"url":"08-package-apps-and-devtools.html","title":"打包应用与开发工具","keywords":"","body":"打包应用与开发工具 使用Conan可以打包和部署应用程序，同样支持打包和部署开发工具，如编译器（例如MinGW）或者构建系统（如CMake）。 本节描述如何打包以及运行可执行程序以及开发工具，以及如何依据build_requires的描述从源码构建各种开发工具或者库（如测试框架等）。 运行以及部署包 使用Conan也可以对包含动态库的可执行程序进行分发和部署。相比较使用其他部署工具，使用Conan具有如下优点： Conan可以作为统一的跨系统和平台的开发和分发工具； 以统一的方式（包管理的方式）管理大量不同的部署配置； 可以使用Conan服务端存储各种系统、平台以及目标的应用程序和运行时； 具体Conan可以使用以下几种不同的方式，对应用程序进行分发和部署。 使用虚拟环境（virtual environments） 我们可以创建包含可执行程序的包。我们以默认的conan new产生的包模板举例：conan new Hello/0.1。 这个源码会产生一个叫做greet的可执行程序，但是可执行程序默认并不会被打包。我们可以修改包配置的package()函数将可执行程序也打包起来： def package(self): self.copy(\"*greet*\", src=\"bin\", dst=\"bin\", keep_path=False) 现在我们可以像以往一样创建包，但是当我们想要运行可执行程序的时候会发现找不到： $ conan create . user/testing ... Hello/0.1@user/testing package(): Copied 1 '.h' files: hello.h Hello/0.1@user/testing package(): Copied 1 '.exe' files: greet.exe Hello/0.1@user/testing package(): Copied 1 '.lib' files: hello.lib $ greet > ... not found... 默认情况下，Conan并不会修改环境，它仅将包创建在本地缓存，而对应的路径不会加入到系统PATH里面，所以greet的可执行程序系统是找不到的。 使用virtualrunenv生成器可以产生对应的文件，能够将包的默认二进制路径加到以下需要的路径中： 将依赖的lib子目录加到DYLD_LIBRARY_PATH环境变量中（为OSX系统中的共享库）； 将依赖的lib子目录加入到LD_LIBRARY_PATH环境中（为Linux系统中的共享库）； 将依赖的bin子目录加入到系统的PATH环境变量中（为可执行程序）； 我们在安装包的时候，指定virtualrunenv： $ conan install Hello/0.1@user/testing -g virtualrunenv 这样就会产生一些文件，可以激活或者去激活需要的环境变量： $ activate_run.sh # $ source activate_run.sh in Unix/Linux $ greet > Hello World! $ deactivate_run.sh # $ source deactivate_run.sh in Unix/Linux Imports 同样可以自定义conanfile(txt或者py的都可以)，在里面使用imports段，这样就会把本地缓存中需要的文件拷贝出来。imports的具体细节会在后面给出示例。 可部署的包 使用deploy函数可以定义将包对应的文件或者构建产物拷贝到系统其它地方的用户空间中。我们给前面的例子加上deploy()方法： def deploy(self): self.copy(\"*\", dst=\"bin\", src=\"bin\") 这时运行conan create . user/testing。可以看到Conan将包的可执行程序拷贝到了当前的bin目录下： $ conan install Hello/0.1@user/testing ... > Hello/0.1@user/testing deploy(): Copied 1 '.exe' files: greet.exe $ bin\\greet.exe > Hello World! 在部署的过程中，Conan创建了一个deploy_manifest.txt文件，里面记录了所有部署的文件及其内容的哈希值。 有的时候部署如果不关心构建时的编译器的话，可以为此调整包的package ID： def package_id(self): del self.info.settings.compiler 进一步了解更多关于deploy函数的用法，参见deploy文档。 使用部署生成器（deploy generator） 部署生成器负责生成文件，用来记录所有被拷贝部署的文件和其哈希值。这使得部署的过程变得可重复。下面的命令会将所有的依赖项移除conan缓冲区，将其汇集到一个独立的空间：conan install . -g deploy 使用json生成器（json generator） 一个更好的方式是使用json生成器：这个生成器在部署时不会将文件拷贝到一个目录中，而是产生一个JSON文件(conanbuildinfo.json)记录所有的依赖信息，包含每个文件在Conan缓冲区中的位置。 $ conan install . -g json conanbuildinfo.json文件是一个为机器生成的文件，可以使用脚本处理它。下面的代码演示了如何从该文件中读取库以及库的目录： import os import json data = json.load(open(\"conanbuildinfo.json\")) dep_lib_dirs = dict() dep_bin_dirs = dict() for dep in data[\"dependencies\"]: root = dep[\"rootpath\"] lib_paths = dep[\"lib_paths\"] bin_paths = dep[\"bin_paths\"] for lib_path in lib_paths: if os.listdir(lib_path): lib_dir = os.path.relpath(lib_path, root) dep_lib_dirs[lib_path] = lib_dir for bin_path in bin_paths: if os.listdir(bin_path): bin_dir = os.path.relpath(bin_path, root) dep_bin_dirs[bin_path] = bin_dir Json生成器的好处在于它只记录部署依赖的文件，但是并不会自行拷贝，将选择权交给用户，用户可以根据需要进行选择并将文件拷贝成想要的目录布局。上面的脚本很容易修改得去执行各种过滤，并完成目标任务。 另外，你也可以自己写一些简单的启动脚本，为你的应用程序进行各种信息配置： executable = \"MyApp\" # just an example varname = \"$APPDIR\" def _format_dirs(dirs): return \":\".join([\"%s/%s\" % (varname, d) for d in dirs]) path = _format_dirs(set(dep_bin_dirs.values())) ld_library_path = _format_dirs(set(dep_lib_dirs.values())) exe = varname + \"/\" + executable content = \"\"\"#!/usr/bin/env bash set -ex export PATH=$PATH:{path} export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{ld_library_path} pushd $(dirname {exe}) $(basename {exe}) popd \"\"\".format(path=path, ld_library_path=ld_library_path, exe=exe) Note 从包开始运行 如果想要在conanfile中运行某个依赖包中的可执行程序，可以在包配置文件中使用run_environment=True参数。它会间接调用RunEnvironment()帮助函数。例如我们想要在构建Consumer包的时候执行greet程序： from conans import ConanFile, tools, RunEnvironment class ConsumerConan(ConanFile): name = \"Consumer\" version = \"0.1\" settings = \"os\", \"compiler\", \"build_type\", \"arch\" requires = \"Hello/0.1@user/testing\" def build(self): self.run(\"greet\", run_environment=True) 现在为Consumer执行conan install和conan build，可以看到greet被执行了。 $ conan install . && conan build . ... Project: Running build() Hello World! 当然也可以显示的通过对应依赖的路径访问可执行程序，如下例。但是这种方法对于有动态库存在的情况下是不行的。 def build(self): path = os.path.join(self.deps_cpp_info[\"Hello\"].rootpath, \"bin\") self.run(\"%s/greet\" % path) 因此，使用run_environment=True是一个更完整的解决方案。 最后，还有另一种做法，那就是可以将包的可执行程序的bin目录直接添加到系统的PATH中。例如在Hello包的配置中如下修改： def package_info(self): self.cpp_info.libs = [\"hello\"] self.env_info.PATH = os.path.join(self.package_folder, \"bin\") 使用这种方法，如果可执行程序需要的话，我们同样可以定义DYLD_LIBRARY_PATH和LD_LIBRARY_PATH。 这样消费方的包就会比较简单，可以直接调用可执行程序： def build(self): self.run(\"greet\") Runtime packages and re-packaging 可以创建只包含可以运行的二进制的包，而将供编译时依赖的头文件和库文件等文件都去掉。比如对于Hello包，通过如下方式就可以做到： from conans import ConanFile class HellorunConan(ConanFile): name = \"HelloRun\" version = \"0.1\" build_requires = \"Hello/0.1@user/testing\" keep_imports = True def imports(self): self.copy(\"greet*\", src=\"bin\", dst=\"bin\") def package(self): self.copy(\"*\") 这样的包配置文件具有如下特点： 它将Hello/0.1@user/testing设置为build_requires。这意味着Hello包仅仅被用于构建HelloRun包，一旦构建结束就不再需要Hello包了； 它使用imports()将所有依赖的可执行文件拷贝出来； 它通过设置keep_imports=True定义将构建阶段（build()函数没有定义，所以用默认的）的产物在构建结束后保留下来； package()函数将build目录下import出来的文件进行打包； 以下是创建并上传包： $ conan create . user/testing $ conan upload HelloRun* --all -r=my-remote 安装及运行这个包，可以使用我们前面介绍过的任一方式，例如 $ conan install HelloRun/0.1@user/testing -g virtualrunenv # You can specify the remote with -r=my-remote # It will not install Hello/0.1@... $ activate_run.sh # $ source activate_run.sh in Unix/Linux $ greet > Hello World! $ deactivate_run.sh # $ source deactivate_run.sh in Unix/Linux 部署挑战 当部署一个C/C++应用程序的时候，有一些特殊的挑战需要应对。这里是一些常见的挑战以及建议的解决方式。 C标准库 一个常见的挑战是，应用程序（无论是C还是C++写的）都可能依赖C的标准库，最常见的就是GNU的C库：glibc。 Glibc其实不仅是C标准库，它包含以下内容： C函数，如malloc()、sin()等，以及语言标准，如C99； POSIX函数，如pthread库； BSD函数，如BSD套接字（socket）； 对操作系统特定API的封装，如Linux的系统调用； 及时你的应用程序没有直接使用这些函数，但是有大量的库在使用这些函数，因此很可能你的库间接依赖到了glibc。 这里的问题是glibc在不同的Linux发行版本中是不兼容的！ 例如我们在新的Ubuntu系统上构建的hello world程序在Centos 6上就会出错： $ /hello /hello: /lib64/libc.so.6: version `GLIBC_2.14' not found (required by /hello) 可以看到，两个Linux系统上glibc的版本是不同的。 还有其它一些C标准库的实现，例如面向嵌入式开发的newlib和musl，也会有一样的挑战。 有几种针对该问题的解决方案： LibcWrapGenerator glibc_version_header bingcc 一些人建议使用glibc的静态库，但是强烈建议不要这样做。一个原因是新的glibc可能使用早期版本不存在的系统调用，如果你的应用程序依赖了新的glibc，可能在某些系统上出现随机的运行时失败，这种问题非常难以调试和定位。 可以通过在Conan包配置里面把不同glibc版本的Linux发行名称作为Conan的子settings（通过在settings.yml文件中定义），这和我们前面讲的通过package_id()和build_id()为包定义兼容性是一样的。这样不同glibc版本的linux将会获取不同的包或者触发自行从源码构建。具体为Conan增加子settings的方式见文档。 C++标准库 一般默认的C++标准库是libstdc++，但是libc++和stlport也是常用的实现版本。 和标准C库glibc类似，应用程序和老系统上的libstdc++链接，也可能会发生错误： $ /hello /hello: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by /hello) /hello: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.26' not found (required by /hello) 幸运的是，对于C++我们可以简单的为编译增加-static-libstdc++的编译标记即可，这是因为C++标准库不会直接使用系统调用，往往是通过libc库帮助其封装。 编译器运行时 除了C和C++运行时库，应用程序可能还会用编译器的运行时库。这些编译器运行时库为应用程序提供了一些低层次的函数，例如支持处理异常的编译器指令。编译器运行时库中的函数往往不会被代码直接调用，大多数时候是由编译器隐式的插入到代码中的。例如下面的可执行程序就依赖了libgcc_s.so。 $ ldd ./a.out libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f6626aee000) 可以使用-static-libgcc的编译期标记来对其静态链接而避免各种应用程序分发问题。另外，可以通过GCC手册尝试找到其它更具体的解决方案。 系统调用（syscall） Linux内核经常会提供新的系统调用，如果应用程序或者第三方库想要使用这些新的能力，有的时候可能会直接调用这些系统API（而非使用glibc的封装）。 上述行为的结果是，应用程序需要在对应的内核上编译，当其发布到其它老的内核系统上执行可能会运行失败。 所以建议尽量使用glibc，或者根据linux内核的版本为定义Conan定义新的settings和子settings，然后用其保证二进制兼容性。 创建Conan包，用于安装开发工具 Conan 1.0引入了两个新的settings，os_build以及arch_build。这两个配置表示运行Conan的机器（而非表示包的目标机器的os和arch），这样就使得我们可以打包一些构建阶段使用的工具，例如编译器或者构建系统等。 如下示例一个打包汇编编译工具nasm的包配置： import os from conans import ConanFile from conans.client import tools class NasmConan(ConanFile): name = \"nasm\" version = \"2.13.01\" license = \"BSD-2-Clause\" url = \"https://github.com/conan-community/conan-nasm-installer\" settings = \"os_build\", \"arch_build\" build_policy = \"missing\" description=\"Nasm for windows. Useful as a build_require.\" def configure(self): if self.settings.os_build != \"Windows\": raise Exception(\"Only windows supported for nasm\") @property def nasm_folder_name(self): return \"nasm-%s\" % self.version def build(self): suffix = \"win32\" if self.settings.arch_build == \"x86\" else \"win64\" nasm_zip_name = \"%s-%s.zip\" % (self.nasm_folder_name, suffix) tools.download(\"http://www.nasm.us/pub/nasm/releasebuilds/\" \"%s/%s/%s\" % (self.version, suffix, nasm_zip_name), nasm_zip_name) self.output.warn(\"Downloading nasm: \" \"http://www.nasm.us/pub/nasm/releasebuilds\" \"/%s/%s/%s\" % (self.version, suffix, nasm_zip_name)) tools.unzip(nasm_zip_name) os.unlink(nasm_zip_name) def package(self): self.copy(\"*\", dst=\"\", keep_path=True) self.copy(\"license*\", dst=\"\", src=self.nasm_folder_name, keep_path=False, ignore_case=True) def package_info(self): self.output.info(\"Using %s version\" % self.nasm_folder_name) self.env_info.path.append(os.path.join(self.package_folder, self.nasm_folder_name)) 上面的包配置中有几个值得注意的点： configure()函数只支持Windows，其它的配置将抛出异常； build()函数下载对应的文件以及unzip它； package()函数将所有解压的文件拷贝到包目录下； package_info()函数使用self.env_info将包的bin目录加入到系统的环境变量path中； 这个包有两个不同于一般Conan包的地方： 没有source()函数。这是因为当你编译一个库，需要从源码执行构建。而在本例中，我们直接下载二进制程序，build函数仅仅完成下载以及解压，并不需要源码。当然，如果你需要从源码构建工具，你也可以像之前那样创建包配置； package_info()函数使用了self.env_info对象。使用self.env_info对象，包可以在依赖这个构建工具的包执行build()、package()和imports()之前先自动的声明环境变量。这样工具的消费者就可以方便的使用工具，而不用自己先得去设置好系统path； 在其它的包配置文件中使用工具包（tool package） 当你依赖一个声明了self.env_info变量的包配置文件的时候，self.env_info中的环境变量将会自动应用。例如看看MinGW的包配置文件 conanfile.py (https://github.com/conan-community/conan-mingw-installer)。 class MingwInstallerConan(ConanFile): name = \"mingw_installer\" ... build_requires = \"7zip/19.00\" def build(self): keychain = \"%s_%s_%s_%s\" % (str(self.settings.compiler.version).replace(\".\", \"\"), self.settings.arch_build, self.settings.compiler.exception, self.settings.compiler.threads) files = { ... } tools.download(files[keychain], \"file.7z\") self.run(\"7z x file.7z\") ... 上面的文件中声明了build_requires，依赖了7zip，用于在下载了MinGW安装器之后执行解压。因此，下载了MinGW安装器后，7z的可执行程序将会在PATH中，因为它依赖的7zip包的package_info()里面对此做了声明。 注意：一些构建依赖有可能需要设置os、compiler或者arch来从源码构建它们。这些情况下，包的配置文件可能如下： settings = \"os_build\", \"arch_build\", \"arch\", \"compiler\" ... def build(self): cmake = CMake(self) ... def package_id(self): self.info.include_build_settings() del self.info.settings.compiler del self.info.settings.arch 上面package_id()删除只为从源码构建的settings，保留了用于包分发的os_build和arch_build选项。 在你的系统中使用工具包（tool packages） 可以使用virtualenv generator来使用安装到你机器上的工具包。例如，基于windows上使用MinGW和CMake： 在你的工程外创建一个独立的目录，用于保存和配置全局开发环境: $ mkdir my_cpp_environ $ cd my_cpp_environ 创建一个conanfile.txt文件： [requires] mingw_installer/1.0@conan/stable cmake/3.16.3 [generators] virtualenv 安装依赖：conan install； 在shell中激活虚拟环境： $ activate (my_cpp_environ)$ 检查工具是否在path中： (my_cpp_environ)$ gcc --version > gcc (x86_64-posix-seh-rev1, Built by MinGW-W64 project) 4.9.2 Copyright (C) 2014 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. (my_cpp_environ)$ cmake --version > cmake version 3.16.3 CMake suite maintained and supported by Kitware (kitware.com/cmake). 可以通过去激活脚本将虚拟环境去激活： (my_cpp_environ)$ deactivate 构建时依赖 有一些包并不适合增加到包的依赖里面，例如你有一个Zlib包依赖于包Cmake/3.4，这时你需要考虑依赖CMake仅是为了构建Zlib？ 有一些依赖仅仅是为了从源码构建包时需要； 这些大多都是一些开发工具、编译器、构建系统、代码分析、测试库等等； 这些依赖往往和包的交付后使用无关，它们仅仅用于包的生成过程； 对于这些工具，你并不会添加太多的版本，对这些依赖的修改也希望能尽可能简单； 有一些工具链甚至不被包创建时考虑在内，例如将zlib交叉编译到Android系统，虽然在这种场景下Android工具链也是构建时依赖； 为了满足上述需求，Conan实现了build_requires。 声明构建时依赖 构建时依赖可以通过profile文件来声明： [build_requires] Tool1/0.1@user/channel Tool2/0.1@user/channel, Tool3/0.1@user/channel *: Tool4/0.1@user/channel MyPkg*: Tool5/0.1@user/channel &: Tool6/0.1@user/channel &!: Tool7/0.1@user/channel 在profile中构建时依赖可以通过pattern来指定。不同的包可以指定不同的构建时依赖。上例中Tool1、Tool2、Tool3以及Tool4将会被用于所有的包（当执行conan install或者conan create时）。Tool5将会被应用于以“MyPkg”开头的包。&用于没有在conanfile中指明名称和版本的包，而&!则正好相反。 不要忘了，包的消费者的conanfile可能在test_package目录下，或者通过conan install传入，这些也会使用上述profile中的规则。 包的配置文件中的build_requires属性以及build_requirements()函数也能够用来指定构建时依赖。 class MyPkg(ConanFile): build_requires = \"ToolA/0.2@user/testing\", \"ToolB/0.2@user/testing\" def build_requirements(self): # useful for example for conditional build_requires # This means, if we are running on a Windows machine, require ToolWin if platform.system() == \"Windows\": self.build_requires(\"ToolWin/0.1@user/stable\") 上面ToolA和ToolB将会在构建这个包的时候获取，而ToolWin则只会在Windows上使用。 如果build_requirements()和build_requires中定义了相同的包名，则build_requirements()优先。 根据规则，如果profile中定义了编译期依赖，包配置文件中的定义的编译期依赖如果具有相同的包名，则会覆盖profile中的。 构建时依赖的特点 无论构建时依赖定义在build_requires中还是定义在profile中，它们都具有相同的特性： 构建时依赖，在使用它们的包从源码开始构建的时候，并且和定义的pattern相匹配的时候，构建时依赖的包才会被获取；否则都不会检查这些构建时依赖的包是否存在； 通过Profile或者通过命令行传入的Options以及环境变量都会影响到包的构建时依赖的选择。例如你可以通过profile或者命令行指定需要安装cmake/3.16.3版本； 如果构建时依赖包满足匹配，则deps_cpp_info和deps_env_info的成员将会被激活。deps_cpp_info的成员有include目录、library名称、编译参数（CFLAGS、CXXFLAGS，LINKFLAGS）、sysroot等，将会从构建时依赖包的self.cpp_info的值中应用；而deps_env_info的成员，如PATH、PYTHONPATH等将作为环境变量被激活； 构建时依赖同样会被传递。每个依赖可以继续声明自己的依赖，包括普通依赖和构建时依赖。构建时依赖的冲突解决和依赖覆写规则和普通依赖是一样的； Conan一样会为匹配的构建时依赖创建依赖图谱，并将其缓存下来。构建时依赖被安装后缓存在Conan的本地缓存区； 构建时依赖不影响包二进制的package ID。如果使用一个不同的构建时依赖产生出一个不同的二进制，你应当考虑增加options或者settings以反映出构建时依赖对二进制兼容性的影响； conan info不会列出构建时依赖的包； 测试框架库 一个使用构建时依赖的例子就是测试框架。测试框架往往被实现为库，我们下面的例子中假设有一个叫做mytest_framework的测试框架库，并且已经存在其对应的Conan包。 下面的例子中，在包配置文件中使用逻辑判断检查构建时依赖是否存在： def build(self): cmake = CMake(self) enable_testing = \"mytest_framework\" in self.deps_cpp_info.deps cmake.configure(defs={\"ENABLE_TESTING\": enable_testing}) cmake.build() if enable_testing: cmake.test() 同时，包的CMakeLists.txt如下： project(PackageTest CXX) cmake_minimum_required(VERSION 2.8.12) include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) conan_basic_setup() if(ENABLE_TESTING) add_executable(example test.cpp) target_link_libraries(example ${CONAN_LIBS}) enable_testing() add_test(NAME example WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/bin COMMAND example) endif() 此时我们执行conan install，包的配置文件并不会获取mytest_framework也不会构建测试。 但是如果定义如下的profile （例如mytest_profile）： [build_requires] mytest_framework/0.1@user/channel 然后调用下面的命令，将会获取mytest_framework，并且构建并运行测试。 $ conan install . --profile=mytest_profile 共用的python代码 构建时依赖也可以用来注入或者重用包配置文件中的python代码。 如下Conan包用来封装和重用mypythontool.py文件： import os from conans import ConanFile class Tool(ConanFile): name = \"PythonTool\" version = \"0.1\" exports_sources = \"mypythontool.py\" def package(self): self.copy(\"mypythontool.py\") def package_info(self): self.env_info.PYTHONPATH.append(self.package_folder) 然后，如果在profile中定义了构建时依赖： [build_requires] PythonTool/0.1@user/channel 这样包里封装的Python代码就能被其它包配置文件复用： def build(self): self.run(\"mytool\") import mypythontool self.output.info(mypythontool.hello_world()) 注意：这种重用python代码的方式，将会被Conan新提供的python_requires的方式替代，具体请参考Python Requires的文档。 Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"09-versioning.html":{"url":"09-versioning.html","title":"版本管理","keywords":"","body":"版本管理 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"10-master-conan.html":{"url":"10-master-conan.html","title":"Conan进阶","keywords":"","body":"Conan进阶 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"11-systems-and-cross-building.html":{"url":"11-systems-and-cross-building.html","title":"系统及交叉编译","keywords":"","body":"系统及交叉编译 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"12-extending-conan.html":{"url":"12-extending-conan.html","title":"扩展Conan","keywords":"","body":"扩展Conan // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"13-integrations.html":{"url":"13-integrations.html","title":"集成","keywords":"","body":"集成 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"14-confituration.html":{"url":"14-confituration.html","title":"配置","keywords":"","body":"配置 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"15-howtos.html":{"url":"15-howtos.html","title":"使用技巧","keywords":"","body":"使用技巧 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "},"16-reference.html":{"url":"16-reference.html","title":"引用","keywords":"","body":"引用 // TODO Copyright © CCUP 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-08 23:34:06 "}}